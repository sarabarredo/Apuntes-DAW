---
id: sistemas-informaticos
sidebar_position: 0
title: Sistemas Informáticos
toc_max_heading_level: 3
---

## UD1.- Software de un sistema informático

![Esquema Unidad 1 Sistemas Informáticos](../../static/img/sistemas-informaticos-unidad-1.jpg)

### 1.- Sistemas informáticos. Introducción.

Los **sistemas informáticos** realizan tareas de **almacenamiento**, **elaboración** y **presentación** de datos.

Sistema informático: una o más computadoras, el software asociado, los periféricos, los terminales, los operadores humanos, los procesos físicos, los medios de transmisión de la información, etc., que constituyen un todo autónomo capaz de realizar un tratamiento de la información. 

Un sistema informático se compone de:

- Elementos físicos o hardware. 
- Elementos lógicos o software.
- El usuario humano.

### 2.- Software de un sistema informático
#### 2.1.- Requisitos e instalación

El **software** está formado por **programas**, **estructura de datos** y **documentación**.

Para la instalación de un software, debemos seguir los siguientes pasos:

1. Determinación del equipo necesario.
2. Ejecución del programa de instalación.
3. Configuración de la aplicación.

**Determinación del equipo necesario**

Una aplicación creada para una plataforma no podrá ser instalada en otra distinta, ni tampoco si nuestro sistema informático no cumple los requisitos mínimos. 

**Niveles de requisitos para la implantación de aplicaciones**

**1. Equipo básico**
- Plataforma hardware.
- Tipo de microprocesador.
- RAM mínima necesaria. 
- Espacio mínimo necesariamente disponible en el soporte de almacenamiento.
- Plataforma software.
- Resolución recomendada del monitor.
- Tarjeta gráfica necesaria.

**2. Equipo opcional**

- Plataforma hardware recomendada.
- Cantidad de memoria adicional recomendada.
- Presencia de coprocesador matemático (para aplicaciones que realicen gran cantidad de cálculos).
- Tipo de impresora.
- Capacidad recomendada para la tarjeta gráfica.

**3. Equipo en red**

Actualmente muchos fabricantes diseñan las aplicaciones para su funcionamiento en red. El fabricante indicará si la aplicación se ha diseñado para trabajar en red, las configuraciones para el servidor y los clientes, así como los sistemas operativos en red bajo los que puede trabajar.
El  fabricante indicará además si existe alguna limitación en cuanto al número máximo de clientes que pueden trabajar con la aplicación. Así, por cada estación en la  que se instale la aplicación habría que adquirir una licencia de uso para los ordenadores cliente.

**Ejecución del programa de instalación**

La mayoría de las aplicaciones presentan dos niveles de instalación en función de los conocimientos del usuario:

- **Instalación básica**. Diseñada para usuarios con pocos conocimientos informáticos. El programa realizará una instalación en función de los elementos que detecte en el equipo y según unos parámetros básicos establecidos por defecto por el fabricante.
- **Instalación personalizada o avanzada**. Permite al usuario incluir o eliminar elementos de la aplicación con el fin de optimizar los recursos sistema informático, instalando sólo aquellos elementos de la aplicación que se van a utilizar. 

**Configuración de la aplicación**

Una vez instalada la aplicación, el usuario debe configurar el entorno de trabajo. Consiste en definir una serie de parámetros que adecuen el funcionamiento de la aplicación, tales como:

- Ajuste y distribución de la pantalla.
- Definición de directorios de trabajo.

#### 2.2.- Tipos de aplicaciones informáticas

El software se suele clasificar en dos tipos:

- **Aplicaciones de propósito general**. Son las que utilizamos casi todos los usuarios de ordenadores (editores y procesadores de texto, hojas de cálculo, comunicación, generador de presentaciones, antivirus, navegadores web, gestores de archivos, calculadoras, visores pdf...).

- **Aplicaciones de propósito específico**. Son las que se utilizan para el desempeño de funciones específicas, científicas, técnicas o de gestión (administración, contabilidad, facturación, gestión de almacén, entornos de desarrollo, administración de bases de datos, diseño gráfico, ingeniería...)

#### 2.3.- Licencias del software

Las **licencias software** sirven para establecer un contrato entre el **autor de una aplicación** y el **usuario**. En el contrato se definen con precisión los derechos y deberes de ambas partes, es decir, los“**actos de explotación legales**.

Desde el punto de vista de licencia, el software puede ser:

**Software propietario o privativo**

La empresa que desarrolla el software lo vende con limites sobre uso, modiﬁcación o redistribución del software. Los tipos de licencias privativas mas utilizadas son:

- **Licencia CLUF**: se compra el producto en un CD o descargado de Internet, limitándonos el uso del producto a un número de ordenadores o número de instalaciones.
- **Licencia OEM**: software preinstalado en un equipo nuevo.
- **Licencia por volumen (corporativas)**: las empresas grandes adquieren un producto para una gran cantidad de ordenadores.

Casos particulares del software propietario:

- **Freeware**: se usa para el software que puede distribuirse libremente pero no modiﬁcarse. Tampoco suelen facilitan el código fuente. 
- **Shareware**: tiene límites de uso o funcionalidades. Se permite su redistribución, pero no su código. El objetivo es probar un software, y si nos gusta comprarlo.

**Software libre. Licencia GNU**

El software libre autoriza:

- Utilizar el programa, para cualquier propósito.
- Estudiar cómo funciona el programa y adaptarlo a tus necesidades, debe proporcionarse las fuentes, directa o indirectamente, pero siempre de forma fácil y asequible.
- Distribuir copias.
- Mejorar el programa y hacer públicas las mejoras a los demás.

En el momento que no se cumpla una de las cuatro libertades, el software no es libre.

Un software libre se puede distribuir comercialmente, pues en el concepto "software libre" no se habla nada de "gratuidad".

Un tipo de licencia libre, muy utilizado hoy día es **GNU-GPL**, que trata de proteger al autor. Cualquier modificación se debe distribuir de nuevo con una licencia GNU-GPL y citando la fuente original. Así, se evita que otros autores se apropien de un trabajo libre. 

**Protección jurídica del software. Copyright**

- El hardware está protegidos por patentes, pero el software no, ya que se considera algo intangible.
- En España, el software está protegido por la Ley de Propiedad Intelectual modificada. LPI (Año 2006).
- La Ley de propiedad intelectual, protege los libros, la música y el software.
- En el artículo 101 de la LPI, se dice: “Los derechos sobre los programas de ordenador, así como sus sucesivas versiones y los programas derivados, podrán ser objeto de inscripción en el Registro” de la Propiedad Intelectual.
- El Registro es público. Una vez, que la empresa inscriba su obra en el registro, podrá anteponer en la obra el símbolo del copyright ©, precisando lugar y año de divulgación.

**Copyleft frente a copyright**

- El mundo libre, también ha creado sus propios derechos copyleft.
- Frente al software privativo, que se registra en la Ley de Propiedad Intelectual y se establece el copyright, en el software libre se estable el copyleft.- El objetivo de Copyleft es asegurar las licencias GPL, que son software libre, pero que al distribuirlo o modificarlo, se obliga a difundir quien fué el autor del software.
-  En internet, es muy fácil encontrar manuales de informática con licencia copyleft.
- La letra C normal refleja que hay copyright, y la obra es privada y no se puede copiar.
- La letra C invertida, refleja que hay copyleft y la obra es libre, se puede copiar, reutilizar pero nombrando siempre al autor, y volviendo a difundir la obra modificada de forma libre.

### 3.- Introducción a sistemas operativos

Un **sistema operativo** es un conjunto de programas que se encarga de **gestionar los recursos hardware y software del ordenador**, por lo que actúa como una interfaz entre los programas de aplicación del usuario y el hardware puro.

#### 3.1.- Definición, objetivos, kernel y subsistemas de los sistemas operativos

Objetivos de los sistemas operativos:

- Abstraer al usuario de la complejidad del hardware.
- Permitir que los recursos del ordenador se utilicen de la forma más eficiente posible.
- Permitir la ejecución de programas.
- Acceder a los dispositivos de entrada/salida.
- Proporcionar una estructura y conjunto de operaciones para el sistema de archivos.
- Detectar y dar respuesta ante errores.
- Gestionar las comunicaciones en red y permitir a los usuarios compartir datos.

**El kernel o núcleo**

Para realizar todos estas funciones, existe el kernel o núcleo. Representa sólo una pequeña parte de todo lo que es el sistema operativo, pero es una de las partes que más se utiliza. El núcleo reside por lo general en la memoria principal (RAM).

Resumiendo, el núcleo se encarga de:

- Gestión de procesos.
- Gestión de memoria.
- Gestión de archivos.
- Gestión de entrada y salida.

#### 3.2.- Tipos de sistemas operativos

**Clasificación de los SO según su estructura**

- **Monolíticos**. Es la estructura de los primeros sistemas operativos, consistía en un solo programa desarrollado con rutinas entrelazadas que podían llamarse entre sí. Por lo general, eran sistemas operativos hechos a medida, pero difíciles de mantener.

- **Jerárquicos**. Conforme las necesidades de los usuarios aumentaron, los sistemas operativos fueron creciendo en complejidad y funciones. Esto llevó a que se hiciera necesaria una mayor organización del software del sistema operativo, dividiéndose en partes más pequeñas, diferenciadas por funciones y con una interfaz clara para interoperar con los demás elementos. Ejemplo: MULTICS.

- **Capas**. El sistema operativo se organiza por capas, las capas superiores utilizan las inferiores. De esta forma, cada capa solo se fija en los detalles suyos. Ejemplo: THE.

- **Microkernel**. Los ordenadores son muy rápidos y realizan muchos cálculos. Hay muchos fallos. Para incrementar la tolerancia a fallos, se dividen en pequeños núcleos: operaciones de entrada/salida, gestión de memoria, del sistema de archivos, etc. Ejemplo: MINIX.

- **Cliente-servidor**. Basada en la estructura microkernel. El cliente solicita una petición de un servicio en la red, y el servidor responde.

- **Máquina virtual**. Integra distintos sistemas operativos en una sola máquina. En cada una de ellas, se puede ejecutar un sistema operativo distinto. Ejemplo: VMware y VirtualBox.

**Clasificación de los SO por los servicios que ofrecen**

| Criterio | Tipo |
| :--- | :--- |
| Número de usuarios | * **Monousuario**: solo un usuario utiliza el SO al mismo tiempo. Ejemplo: Ms-Dos. <br /> * **Multiusuario**: pueden trabajar varios usuarios al mismo tiempo, bien en el mismo ordenador, bien desde otro ordenador a través de consolas. Ejemplos: Unix, Windows 10. |
| Número de procesos | * **Monoproceso o monotarea**: solo se puede ejecutar un proceso a la vez en cada núcleo. Ejemplo: MS-DOS. <br /> * **Multiproceso o multitarea**: se pueden ejecutar varios procesos a la vez. Ejemplos: Windows actuales, Unix/Linux, Mac OS. |
| Número de procesadores | * **Monoprocesador**: el SO solo se puede utilizar en ordenadores con 1 procesador. Ejemplo: MS-Dos. <br /> * **Multiprocesador**: el SO se puede utilizar en ordenadores con varios procesadores. Ejemplos: Windows actuales, Unix/Linux. |

**Clasificación de los SO por su forma**

| Criterio | Tipo |
| :--- | :--- |
| En red | Estos sistemas tienen la capacidad de interactuar con los sistemas operativos de otras máquinas a través de la red. Ejemplo: Windows Server, Linux. |
| Distribuidos | Las funciones se distribuyen entre diferentes ordenadores, logrando integrar recursos en una sola máquina virtual que es a la que el usuario accede de forma transparente. En este caso, el usuario no necesita saber la ubicación de los recursos, sino que los referencia por su nombre y los utiliza como si fueran locales a su lugar de trabajo habitual. Ejemplo: MOSIX. |

### 4.- Gestión de procesos

#### 4.1.- Estados de los procesos. Bloque de control de procesos

**Definición de proceso**

Cada vez que se abre un programa informático, se genera un proceso principal. Un programa tiene varias instrucciones, y se ejecuta de forma secuencial, es decir, una instrucción detrás de otra.

Cuando se inicia el programa principal, se inicia el proceso principal que controla el programa hasta que finalice el programa. Para ejecutar cada instrucción se inicia un subproceso, de forma que lo habitual es que un programa tenga varios procesos, también llamados subprocesos o hilos de ejecución.

El proceso se ejecutará y finalizará de forma correcta o por error. Estas ideas nos dejan entrever lo que se llama "estados de los procesos".

**Estados de los procesos**

Los diferentes estados de un proceso son:

- **En ejecución o activo**: es el que se ejecuta. En cada núcleo de un procesador, solo puede haber un proceso activo.

- **Preparado o espera** : está preparado para su ejecución, pero a la espera de un procesador libre (hay otro proceso en ejecución).

- **Bloqueado o suspendido**: no puede ejecutarse, porque necesita un recurso que está ocupado. Por ejemplo: si hay 2 impresiones, la segunda está bloqueada, hasta que la primera acabe.

- **Muerto**: su ejecución ha terminado o el sistema operativo ha detectado un error fatal y lo ha transferido a dicho estado. Si se apaga el equipo por falta de alimentación eléctrica, todos los procesos pasan a muertos.

**Transición entre estados de los procesos**

El **planificador de procesos** se encarga de pasar los procesos de unos estados a otros. 

Tiene listas independientes para cada estado, pues se gestiona de forma distinta la lista de procesos preparados de la lista de procesos bloqueados.

Cuando un proceso se crea, y se comprueba si se puede ejecutar, pasa a la lista de procesos preparados, y cuando lo decida el planificador, pasa a estar en ejecución (activo).

Una vez en ejecución, puede pasar a cualquiera de los otros estados:

- De **ejecución** puede pasar a **preparado** porque el planificador decida ejecutar otro proceso.
- De **ejecución** puede pasar a **bloqueado** porque necesita algún dato o está en conflicto con otro proceso.
- De **bloqueado** puede pasar a **preparado** cuando se ha resuelto el problema. 
- Desde **todos los estados**, el proceso puede pasar a **muerto**, tanto porque el proceso finalice como debido a errores del sistema operativo o bloqueo infinito.

**Bloque de control de procesos**

El sistema mantiene toda la información sobre un proceso en una tabla llamada **bloque de control de procesos**. Para cada proceso contiene:

1. Identificador único de proceso (*pid*).
2. Estado del proceso.
3. Prioridad.
4. Dirección de la memoria donde está guardada la información relativa al proceso.
5. Información contable, necesaria para que el planificador realice su trabajo (hora de inicio del proceso, tiempo de espera, tiempo de ejecución que resta, etc.).

#### 4.2.- Planificador de procesos. Algoritmos.

Si la multitarea real no existe, ¿por qué es multitarea y lo parece?

Un PC a 3GHz realiza 3 mil millones de operaciones elementales en 1 segundo. Durante ese segundo, el ordenador cambia muchísimas veces de tarea, de forma que parece que se ejecuta todo a la vez.

**Algoritmos de planificación de procesos**

El planificador de procesos del sistema operativo decide qué proceso de la cola de preparados pasa a estar en ejecución en cada momento. Después, puede decidir dejar el tiempo que necesite el proceso, o que ese proceso pase a preparado, pasando otro de la cola de listos a en ejecución. Estas transiciones continuas, entre procesos listos y en ejecución, es lo que da lugar a la multiprogramación, pues aunque se ejecuta un solo proceso en cada núcleo, da la sensación de que se ejecutan varios procesos a la vez o en paralelo.

Los **algoritmos de planificación de procesos** determinan qué proceso pasa a estar activo. Los algoritmos SRT, Round Robin y Prioridades son los más utilizados en sistemas operativos modernos.

| Algoritmo | Descripción |
| --------- | ----------- |
|   FIFO    | Primero en llegar, primero en salir (First Input, First Output). Es el más sencillo, los procesos pasan a activo en el orden que llegaron a preparado. Una vez que el trabajo se inicia, se ejecuta hasta el final. |
|   SJF     | Primero el trabajo más corto (Shortest Job First). De los procesos que están preparados, se selecciona el que tiene menor tiempo de ejecución. Una vez que el trabajo se inicia, se ejecuta hasta el final. |
|   SRT     | Tiempo restante más corto (Shortest Remaining Time). El planificador utiliza el criterio SJF, pero tiene en cuenta los nuevos procesos que puedan llegar al estado preparado. Por ejemplo, si se está ejecutando un proceso A que le quedan 3 instantes, pero llega un nuevo proceso B al estado preparado que solo necesita 1 instante, el proceso A pasa al estado preparado, mientras que B pasa a ejecución por necesitar menos tiempo. Es el primer algoritmo que utiliza la multiprogramación (un proceso activo se deja de ejecutar para que se ejecute otro). Son algoritmos expropiativos (se quita el procesador al proceso activo). |
|   RR (Round Robin)  | Reparte el tiempo del procesador de forma justa y por turnos. Funciona dando a cada proceso una pequeña porción de tiempo, llamada cuanto. Si el proceso no termina en ese tiempo, la CPU lo detiene momentáneamente y lo envía al final de la fila para que espere su próximo turno, pasando inmediatamente al siguiente proceso en la cola. Este ciclo se repite constantemente, asegurando que todos los procesos reciban atención regularmente, lo que se traduce en un tiempo de respuesta rápido y equitativo para el usuario. |
|   Prioridades  | Cada proceso tiene asignada una prioridad y el de mayor prioridad en el estado listo es el que pasa a estar en ejecución. El valor de prioridad puede ser asignado por el usuario o el sistema. Asimismo, el usuario puede cambiar en cualquier momento la prioridad de un proceso. Las prioridades son buenas, pero por si solas tienen el problema de que un proceso con poca prioridad no se ejecutaría nunca. Para solucionar este problema, se mejora el algoritmo utilizando prioridad por envejecimiento (si un proceso lleva mucho tiempo en estado preparado, se sube su prioridad para tener más posibilidades de pasar a activo). |

Observaciones:

- FIFO puede bloquear procesos muy cortos, por estar ejecutando uno muy largo.
- SJF y SRT pueden bloquear procesos muy largos, por ejecutarse siempre los más cortos.
- FIFO y SJF dan malos resultados, pero son muy fáciles de implantar. El sistema operativo realiza pocos cálculos, por lo que no se pierde tiempo. Son los únicos algoritmos monoproceso, monotarea, no multiprogramados o no expropiativos.
- SRT se utiliza bastante en los sistemas operativos actuales, pues se ha comprobado que da un tiempo medio de espera muy bueno.
- Los algoritmos SRT, Round Robin y prioridades dan buenos resultados. Aun así, lo habitual es utilizar varios algoritmos mezclados. De esa forma, se intenta obtener lo mejor de cada uno.
- En sistemas actuales, se suelen utilizar “prioridad con SRT” y “prioridad con Round Robin”. FIFO y SJF, se utilizan como criterios de desempate final.

### 5.- Gestión de memoria

Hemos visto en la gestión de procesos que el recurso compartido es el procesador. Sin embargo, para que un proceso se pueda ejecutar no sólo requiere tiempo de procesamiento sino también estar cargado en memoria principal. Esto es así, porque ningún proceso se puede activar antes de que se le asigne el espacio de memoria que requiere. Así, la memoria se convierte en otro recurso clave que tendrá que gestionar el sistema operativo y la parte encargada de ello se denomina **gestor de memoria**.

#### 5.1.- Particiones fijas, variables y paginación

- Memoria, memoria principal o memoria física: RAM.

- Memoria secundaria: disco duro.

Actualmente la mayoría de los sistemas operativos son sistemas multitarea, en los que va a haber varios procesos simultáneamente en ejecución. Por tanto, deberá haber mecanismos de gestión para distribuir la memoria principal entre todos estos procesos que quieren ejecutarse.

Los primeros algoritmos para este cometido tienen una gestión fácil pero desperdician mucha memoria. Los algoritmos actuales tienen una gestión más complicada a cambio de ser más eficientes.

**Primer Sistema: Gestión de la memoria con particiones fijas**

Consiste en dividir la memoria física disponible en varias particiones de tamaño fijo y asignar cada una de las partes a un proceso.

Ejemplo: Supongamos un equipo antiguo con MS-DOS y una memoria RAM de 4 Mb, los primeros 512 Kb estaban reservados para los programas de MS-Dos. Los 3,5 MB restantes, es donde se cargaban los programas de usuario (procesador de texto, hoja de cálculo,...), se dividen en 3 particiones de distinto tamaño, por ejemplo, 512 KB, 1 MB y 2 MB. Cada tarea o proceso se asigna a una partición. En cada partición, solo puede haber 1 proceso.

En este sistema, se desaprovecha espacio dentro de cada partición. Se produce fragmentación interna (se desperdicia espacio en la memoria, que no puede utilizar otro proceso).

**Segundo sistema: Gestión de la memoria con particiones variables**

No hay particiones, a cada proceso se le asigna el tamaño que hace falta. Cuando termina el proceso se libera ese trozo, y se junta con el espacio libre que haya al lado.

Cada proceso nuevo se carga donde haya espacio, y lo que no se utilice queda libre para otro proceso.

En este sistema, no se pierde espacio dentro de las particiones, pero si pueden desperdiciarse huecos libres que van quedando, pero que no se pueden aprovechar porque son pequeños. Se produce fragmentación externa (se desperdicia espacio en la memoria, pero de forma general, no dentro de una partición)

**Tercer sistema: Paginación**

La memoria se divide en páginas de igual tamaño. Los procesos utilizan las páginas necesarias, no siendo obligatorio que sean contiguas (continuas).

Ejemplo, el tamaño de las páginas suele ser 4KB, si el proceso necesita 31 KB, utilizará 8 páginas libres, independientemente si están juntas o no.

Es más difícil de gestionar y se necesitan computadoras más potentes, pero se aprovecha muy bien la memoria. La fragmentación es casi cero.

Poco a poco, las páginas libres quedan muy desorganizadas. El sistema operativo puede perder tiempo en asignar muchas páginas no contiguas a los procesos, por lo que cada poco tiempo realiza una compactación. Esto consiste en organizar todas las páginas, de forma que tanto las páginas libres como las de los procesos estén juntas.

Por este motivo, la **paginación** es la técnica que se utiliza en la **actualidad**.

#### 5.2.- Memoria virtual (Windows) y memoria swap (Linux)

**Memoria virtual en Windows**

La memoria RAM es cara y limitada. Debido a esto nació este sistema, que consiste en sobrepasar el límite de memoria RAM, guardando la información en el disco duro como si fuera RAM.

La memoria virtual suele tener entre 1 y 2 veces el tamaño de la RAM.

Cada vez que se carga un proceso en la memoria RAM, también se escribe en la memoria virtual. Cuando la RAM se está llenando, se puede borrar las que sobran e introducir las nuevas. Si hacen falta las antiguas, se provocará un fallo de página, y el gestor de memoria traerá dicha parte del proceso de disco a memoria.

De esta forma, aunque la memoria virtual es más lenta que la RAM, si tenemos una RAM de 2 GB, podríamos simular una RAM de 6 GB con la ayuda de la memoria virtual en disco duro.

El archivo `pagefile.sys` oculto en la partición donde está instalado Windows es el archivo de la memoria virtual, también llamado archivo de paginación (pues también utiliza paginación dentro del archivo). Aun así, no hay que confundir la memoria virtual con la paginación a secas.

**Memoria swap o área de intercambio en GNU-Linux**

El concepto es el mismo que memoria virtual. La diferencia es que, en Linux, al instalar el sistema operativo, se crea una partición expresa para este fin. Lo habitual es utilizar entre 1 y 2 veces el tamaño de la RAM.

Ventajas de memoria swap sobre memoria virtual:

- No depende de que la partición de datos esté muy llena.
- Si se pone la swap en la primera partición del disco duro, gana en velocidad, pues esa zona del disco duro es más rápida.

En Linux se utiliza el comando `free` para ver cuanta memoria principal y cuánta swap tiene el equipo y su consumo.

Tendencia actual en la memoria swap o memoria virtual:

Actualmente, los ordenadores tienen memoria RAM muy grande, por lo que se discute si es necesario poner memoria virtual o swap o no configurarla.

En cualquier caso, en un ordenador con RAM muy grande se suele poner como tamaño de la virtual o swap la misma cantidad que tiene de RAM. Si la cantidad de RAM es justa, pondremos el doble. Una razón para seguirla poniendo en Linux, es que la partición swap se utiliza también cuando se hiberna el sistema.

### 6.- Gestión de entrada y salida

Una de las funciones del ordenador es procesar la información, que es obtenida y mostrada a través de los periféricos. La parte del sistema operativo que se encarga de este proceso es la **gestión de la E/S (entrada/salida)**.

#### 6.1.- Estructura y transferencia de datos

**Controladores de dispositivo**

Hay multitud de tipos y fabricantes de periféricos, esto conlleva que tanto el sistema operativo como los fabricantes de periféricos deben estandarizar el acceso a los dispositivos utilizando los controladores de dispositivos.

**Controlador o Driver**: software suministrado por el fabricante del dispositivo o el desarrollador del sistema operativo que actúa como interfaz entre los programas y el hardware.

**Estructura de datos de la E/S**

Se refiere a la estructura de datos que utilizan los dispositivos periféricos para manejar la información y comunicación entre dispositivos o entre estos y la CPU. Las más utilizadas son:

- **Spool**. Los datos de salida se almacenan de forma temporal en una cola situada en un dispositivo de almacenamiento masivo (*spool*), hasta que el periférico requerido se encuentre libre. De este modo se evita que un programa quede retenido porque el periférico no esté disponible. El sistema operativo dispone de llamadas para añadir y eliminar archivos del spool. Se utiliza en dispositivos que no admiten intercalación, como ocurre en la impresora, ya que no puede empezar una impresión hasta que no haya terminado la anterior.

- **Buffers**. Es para dispositivos que pueden atender peticiones de distintos orígenes. Los datos no tienen que enviarse completos, pueden enviarse porciones que el buffer retiene de forma temporal. También se utilizan para acoplar velocidades de distintos dispositivos. Así, si un dispositivo lento va a recibir información más rápido de lo que puede atenderla se emplea un buffer para retener temporalmente la información hasta que el dispositivo pueda asimilarla. Esto ocurre entre una grabadora de DVD y el disco duro, ya que la primera funciona a una menor velocidad que el segundo.

**Transferencia de los datos de la E/S**

Existen distintas formas de transferir los datos de E/S en los sistemas operativos según la intervención de la CPU. Son las siguientes, ordenadas de menos eficientes a más eficientes:

- **E/S programada**. La CPU tiene todo el protagonismo ya que inicia y lleva a cabo la transferencia. Esta técnica repercute en la velocidad de proceso del ordenador, porque la CPU debe dejar todo lo que está haciendo para ocuparse del proceso de entrada/salida.

- **E/S por interrupciones**. La CPU ejecuta la transferencia pero el inicio es pedido por el periférico que indica así su disponibilidad. La CPU no pregunta a los dispositivos sino que son estos los que la avisan cuando es necesario.

- **Acceso directo a memoria (DMA)**. La transferencia es realizada por un controlador especializado. Esta técnica acelera enormemente el proceso de la E/S y libera a la CPU de trabajo. Lo habitual es que los datos que se quieren escribir en el dispositivo o que son leídos del dispositivo provengan o vayan a la memoria del ordenador, pues bien en este caso. la CPU inicia el proceso, pero luego el dispositivo continúa sin necesitar a la CPU, con lo que se acelera mucho el proceso de entrada/salida y se libera a la CPU del proceso.

### 7.- Gestión de archivos
#### 7.1.- Organización lógica: directorios y ficheros

Cada sistema operativo utilizará su propio sistema de archivos, no obstante las operaciones que se pueden realizar sobre el sistema de archivos son bastante similares. Así, todos los sistemas de archivos actuales utilizan los directorios o carpetas para organizar a los archivos.

**Objetivos en la implementación de un sistema de archivos**

- Optimizar el rendimiento mediante un acceso rápido cuando se recupera información.
- Fácil actualización de los archivos.
- Intentar que los archivos desperdicien la menor cantidad de espacio en disco posible.
- Mantenimiento sencillo.
- Fiabilidad para asegurar que los datos sean correctos y fiables.
- Incorporar mecanismos de seguridad y permisos.
- Control de concurrencia.

**Organización lógica del sistema de archivos**

Los sistemas de archivos deben permitir utilizar el medio de almacenamiento (disco) de una forma intuitiva y cómoda, sin conocer los detalles de hardware.

A esto se le llama organización del sistema de archivos y suele coincidir en todos los sistemas de archivos actuales, utilizando el esquema de almacenamiento en archivos y la organización en carpetas o directorios.

Un directorio o carpeta solo es un contenedor, no contiene información, ésta se encuentra en los archivos.

Cada archivo de un sistema tendrá unos atributos que lo identifican:

1. Nombre
2. Extensión
3. Permisos
4. Propietario
5. Fecha de creación
6. Fecha del último acceso
7. Fecha de la última modificación
8. Tamaño actual

**Jerarquía de directorios. Árboles**

Todos los sistemas operativos tienen una estructura jerárquica de almacenamiento de la información en forma de árbol.

### 8.- Virtualización. Software y configuración de máquinas virtuales.

#### 8.1.- Motivación y ventajas de las máquinas virtuales.

Gracias a la virtualización o máquinas virtuales, en un ordenador puede haber varias máquinas distintas ejecutándose.

Las máquinas virtuales se pueden comunicar en una red, siendo vistas como computadores distintas.

Una máquina virtual, se instala y ejecuta bajo un software, de forma que es una carpeta con algunos archivos. El disco duro es un archivo, y el resto de archivos son la configuración de la máquina. De esta forma, resulta muy fácil el traslado de una máquina virtual de un ordenador a otro ordenador.

Términos:

- **Máquina anfitrión, host o servidor:** máquina real donde se instala la aplicación de virtualización.
- **Máquina invitada, huésped o guest**: máquina virtual que se ejecuta dentro de la aplicación.

**Software de virtualización**

Software de varias empresas: Vmware, Oracle, Microsoft, Parallels

- **Vmware**. Software propietario. Tiene muchas versiones, algunas de pago y otras gratuitas (Server, Workstation y Player).

- **VirtualBox**. Software original de Sun Microsystems, comprada posteriormente por Oracle. Tiene dos versiones principales (VirtualBox y VirtualBox OSE).

- **HiperV**. Software propietario de Microsoft para ordenadores con Windows. Tiene dos programas (Virtual PC e Hiper V).

- **Parallels**. Software propietario para ordenadores MAC. Se puede virtualizar tanto Windows como Linux.

#### 8.2.- Instalación y configuración de una máquina virtual nueva

Para crear una máquina, se indican los siguientes parámetros:

1. Nombre.
2. Sistema operativo que se va a instalar.
3. Memoria RAM.
4. Disco duro.

**Diferencia de tamaño fijo y tamaño dinámico al crear un disco duro**

Al crear un disco duro, se puede crear de tamaño dinámico (el archivo crece según metemos información en la máquina virtual) o tamaño fijo (el archivo ocupa siempre el tamaño total del disco duro). 

**Configuración de la máquina virtual**

Una vez creada una máquina virtual, se puede:

- Añadir o eliminar medios de almacenamiento.
- Habilitar los puertos USB de la máquina host.
- Configurar la red (NAT, puente, red interna).
- Compartir carpetas entre la máquina host y la invitada.

**Herramientas de optimización**

Para que las máquinas funcionen con mejores características, hay que instalar las herramientas que adaptan el hardware de la máquina real a la invitada (es decir, instalan u optimizan los drivers). Cada programa tiene su propia herramienta para este fin.

Ventajas de instalar estas herramientas:

- Mejor resolución gráfica.
- Integración del ratón.
- Acceso a carpetas compartidas.
- Compartir el portapapeles.

#### 8.3.- Configuración de VirtualBox

**Instantáneas o snapshots**

Si vamos a instalar algún programa, o queremos hacer pruebas al sistema, y pensamos que pueden fallar esas pruebas, podemos realizar instantáneas al sistema. De esa forma, una vez acabada las nuevas instalaciones o pruebas, podemos decidir, si nos quedamos con la versión más actualizada del Sistema Operativo (Eliminar instantánea) o la versión antigua (Restaurar instantánea). Cada instantánea va generando archivo .vdi nuevos con las diferencias.

**Extensiones de los discos duros, según programas**

- VirtualBox → vdi
- Vmware → vmdk
- Virtual PC → vhd

Aun así, no hay problema de compatibilidad entre VMware y VirtualBox, pues se pueden exportar e importar las máquinas.

**Trasladar una máquina a otro PC**

1. Disco duro. El disco duro de una máquina virtual, es un único archivo .vdi. Este archivo se puede copiar en cualquier otro ordenador y tener una máquina instalada en un momento. Hay que crear la máquina nueva y en el momento de poner disco duro elegir el disco existente con su ruta.

2. Máquina entera. Para ello se debe exportar el servicio virtualizado, obteniendo un archivo con extensión .ova.
Este archivo servirá para importar la máquina en ese PC o en otro. La diferencia, es que el archivo .ova es toda la máquina.

**Administrador de discos de VirtualBox**

Al igual que un disco duro físico no puede estar en 2 sitios a la vez, no podemos tener duplicado el disco duro en 2 máquinas virtuales, aunque se llamen de forma distinta y tengan cosas distintas.
Cada disco tiene un número de serie y no puede haber 2 archivos .vdi con el mismo número de serie.

**Soluciones**

Hay varias soluciones para copiar un disco sin provocar errores por UUID:

1. Copiar el disco (crea una copia con UUID distinto).
2. Clonar la máquina (no solo copia el disco, sino que crea otra máquina con sus archivos de configuración).
3. Exportar el servicio virtualizado (se genera el archivo .ova).

**Configuración de red en VirtualBox**

La máquina virtual tiene una tarjeta de red virtual (se pueden poner varias tarjetas de red virtuales).
Esta tarjeta de red virtual se conecta con la máquina anfitrión según la configuración que se seleccione. Las configuraciones posibles son:

- **No conectado** -> La máquina invitada no tiene red.
- **NAT: Network Address Translation** -> Modo más simple, pues sin ninguna configuración adicional la máquina virtual navega por Internet. La máquina virtual no se puede conectar ni con la anfitrión ni con otras máquinas virtuales y, por tanto, no puede compartir archivos. La dirección IP en la máquina invitada la asigna dinámicamente Virtualbox. Este modo es perfecto para realizar todo tipo de pruebas, ya que la red no puede infectar a la máquina y al contrario.
- **Bridged / Adaptador Puente** -> Se forma un puente entre la tarjeta virtual de la máquina invitada y la tarjeta real de la máquina anfitrión. Es como si fueran la misma tarjeta. A todos los efectos la máquina invitada es como si estuviera conectada a la red como una máquina real.
- **Red Interna** -> Crear una red interna visible entre las máquinas invitadas, pero no con la anfitrión ni con la red general. Se utiliza cuando queremos tener una red entre las máquinas virtuales.
- **Host-only networking / Adaptador sólo-anfitrión** -> En este modo cada máquina invitada solo puede comunicarse con la máquina anfitrión, sin que se puedan comunicar entre las invitadas. El direccionamiento de las mismas es dinámico y lo asigna VirtualBox.

## UD2.- Hardware de un sistema informático

![Esquema Unidad 2 Sistemas Informáticos](../../static/img/sistemas-informaticos-unidad-2.jpg)

### 1.- Computadores digitales. Evolución.

En la actualidad, todos los equipos que utilizamos son **computadores digitales**. Estos operan únicamente manejando dos estados, representados por **0** y **1** (sistema binario). 

- Esta base binaria proviene de los **transistores** dentro del microprocesador, que actúan como interruptores:
    - **Encendido** (paso de corriente) se asigna al valor **1**.
    - **Apagado** (sin paso de corriente) se asigna al valor **0**.
- Cada uno de estos estados se representa mediante un **bit**.
- Las operaciones lógicas y matemáticas que realiza el microprocesador se ejecutan mediante **circuitos electrónicos** que simulan las funciones booleanas.

El mundo digital es **discreto y finito** (solo representa algunos valores), mientras que el mundo analógico es **continuo e infinito** (puede representar todos los valores).

Aunque la conversión de datos analógicos a digitales produce errores porque solo se representan algunos valores, el mundo digital es preferido en la computación actual por sus ventajas prácticas y técnicas:
- **Exactitud (Inmunidad al ruido):** la comunicación digital es inherentemente más exacta y más inmune al ruido que la analógica.
- **Economía:** la comunicación digital es más barata de implementar.

**Conclusión:** los ordenadores actuales son digitales porque, a pesar de no poder representar todos los datos, los valores que sí representan son **más exactos**, **más inmunes al error** y se obtienen de forma **más económica**.

**Evolución de los computadores digitales**

| Generación | Periodo | Tecnología | Características |
| :--- | :--- | :--- | :--- |
| **Primera** | 1940-1960 | **Válvulas de vacío** | Eran muy pesados (ej., el **ENIAC** de 1946 pesaba 30 toneladas) y tenían poca potencia |
| **Segunda** | 1960-1965 | **Transistores** (sustituyen a las válvulas) | Desarrollados por los Laboratorios Bell. El peso disminuye, pero la potencia sigue siendo limitada |
| **Tercera** | 1965-1975 | **Circuitos Integrados** | Aumenta significativamente la **velocidad** de procesamiento |
| **Cuarta** | 1975-hoy | **Microprocesador** | Todos los circuitos integrados se condensan en una sola pastilla. Se consolida la **Arquitectura Von Neumann** que se utiliza hasta hoy |
| **Quinta** | 1985-hoy | **Inteligencia Artificial y Sistemas Expertos** | Los computadores tienen la capacidad de aprender de sus propios errores y cálculos anteriores | 

### 2.- Arquitectura Von Neumann

La **Arquitectura Von Neumann** es el modelo base de los computadores actuales, diseñado por John Von Neumann. Su gran novedad fue un concepto conocido como el **programa almacenado**: tanto los **datos** como las **instrucciones** de los programas se guardan en la **Memoria Principal (RAM)**, sin distinción. Es la **CPU** la encargada de diferenciar qué es dato y qué es instrucción en el momento de la ejecución. Este modelo se ha utilizado ininterrumpidamente desde el primer PC de IBM en 1981.

La arquitectura se compone de cuatro unidades interconectadas por buses:

1. **CPU (Unidad Central de Proceso):** el cerebro que ejecuta los programas.
2. **Memoria Principal (RAM):** almacena datos e instrucciones.
3. **Unidad de Entrada/Salida (E/S):** gestiona la comunicación con periféricos.
4. **Buses:** canales que transportan datos e instrucciones entre las unidades.

**1. Memoria Principal (RAM)**
    - Almacena los **datos y las instrucciones** de los programas activos y toda la información necesaria para el sistema.
    - Es **volátil**; su contenido se pierde cuando el ordenador se apaga.
    - Está formada por celdas de igual longitud, conocidas como **registros**.

**2. CPU: Unidad Central de Proceso**
    - Es el componente principal, y está compuesto por:
        - **Unidad de Control (UC):** se encarga de **gobernar** la ejecución de los programas, **controlando la secuencia** de las instrucciones e interpretando su significado. Controla también a los demás componentes del sistema (memoria, periféricos).
        - **Unidad Aritmético-Lógica (ALU):** realiza todos los **cálculos matemáticos** y **operaciones lógicas**.
        - **Registros y Caché:** son memorias muy rápidas ubicadas dentro de la CPU para almacenar datos o la dirección de la siguiente instrucción, con el fin de **reducir el acceso a la lenta memoria principal**.

    :::info Procesador de n bits
    Si un procesador es de **64 bits**, significa que la **longitud de palabra** (el tamaño de datos e instrucciones que maneja) es de 64 bits.

    La longitud de los registros, el ancho de la memoria caché, y el ancho de los **buses de datos y direcciones** suelen ser iguales a la longitud de palabra del procesador.
    :::

**3. Unidad de Entrada/Salida (E/S)**
    - Circuitos electrónicos que permiten el **intercambio de información** entre la CPU y los periféricos. Carga programas/datos a la RAM (Entrada) y saca resultados (Salida).
    - Los **discos duros** son considerados **dispositivos de E/S** bajo este modelo, ya que son externos a la memoria principal (RAM).

**4. Buses**
    - Conjunto de circuitos que permiten la **comunicación en paralelo** entre la CPU y el resto de unidades:
        - **Bus de Datos e Instrucciones:** traslada datos e instrucciones entre la memoria principal y las demás unidades.
        - **Bus de Control:** la CPU envía **órdenes** (microórdenes) y recibe **señales de estado** de las otras unidades.
        - **Bus de Direcciones:** transmite la **dirección de destino** o de origen de los datos que circulan por el bus de datos (ej., la posición de memoria a leer).

**Ejecución de las instrucciones**

Para que un programa se ejecute, debe estar alojado en la RAM. Las instrucciones se ejecutan secuencialmente, leyendo posiciones consecutivas de memoria La ejecución se divide en dos fases principales por cada instrucción:
    1.  **Fase de Búsqueda (Fetch):**
        * El **Contador de Programa (CP)** almacena la dirección de la siguiente instrucción a leer.
        * La instrucción se localiza en la memoria y se lleva a la CPU (UC).
        * La instrucción se almacena en el **Registro de Instrucción (RI)**.
    2.  **Fase de Ejecución:**
        * La **ALU** realiza el cálculo u operación lógica.
        * La ALU utiliza **registros operandos** para introducir datos y un **Registro Acumulador (AC)** para guardar el resultado.

:::info Jerarquía de Memoria
El computador utiliza múltiples tipos de memoria (Registros → Caché → RAM → Discos Duros) debido a un compromiso entre **coste y velocidad**. Cuanto más **rápida** es la memoria (más cerca de la CPU), **mayor es su precio** y **menor es su tamaño**.
:::

<iframe 
    width="560" 
    height="315" 
    src="https://www.youtube.com/embed/SxFG18C4gXQ?si=N1oqnWEI7tKqCaCm&amp;disablekb=1" 
    title="YouTube video player" 
    frameborder="0" 
    allowfullscreen>
</iframe>

### 3.- La CPU. El microprocesador.

El **microprocesador** es el elemento que representa la **CPU** (Unidad Central de Proceso) en la arquitectura Von Neumann. Es un microchip complejo, generalmente cerámico, que contiene millones de microcomponentes (transistores) y se acopla a la placa base mediante un zócalo. Los principales fabricantes de procesadores son **AMD** e **Intel**. Actualmente, todos los procesadores fabricados son de **64 bits**.

Debido al calor generado, la CPU requiere **refrigeración** (ventiladores o sistemas líquidos) para evitar daños.

**Características que definen un procesador**

| Característica | Descripción | Medida |
| :--- | :--- | :--- |
| Velocidad/Frecuencia | Ciclos por segundo u **operaciones elementales** que realiza el procesador | **GHz** (ej. 3 GHz = 3.000 millones de operaciones por segundo) |
| Litografía | Mide la tecnología de fabricación (el **tamaño de los transistores**). A menor tamaño, menor energía necesaria, y por tanto, **menor consumo y menor calor** generado | **Nanómetros** (nm). |
| Arquitectura | Define la **longitud de palabra** (ej. 64 bits), que es el tamaño de datos e instrucciones que el procesador y sus buses pueden manejar | Bits |

**Núcleos e hilos de ejecución**

La mejora de la CPU desde 2004 (cuando se alcanzó la velocidad máxima por calentamiento) se logró incorporando **múltiples núcleos**.

- **Núcleos (Cores):** cada núcleo es una unidad de procesamiento independiente que puede ejecutar un **proceso** por separado (los procesadores de alta gama tienen 6 a 8 núcleos para PC, y más para servidores).
- **Hilos (Threads):** en muchos procesadores, cada núcleo se divide en 2 hilos de ejecución. Un hilo permite que un proceso principal se subdivida en **subprocesos** que se ejecutan simultáneamente, mejorando la eficiencia.

**Memoria caché del procesador**

La **memoria caché** es una memoria muy rápida y cara ubicada dentro del procesador. Su objetivo es **reducir el número de accesos a la RAM** guardando los datos que se utilizan con mayor frecuencia, basándose en la regla 80/20 (el 20% de los datos se usan el 80% del tiempo). La caché se organiza en una jerarquía de hasta tres niveles:

| Nivel | Ubicación/Compartición | Velocidad/Precio | Tamaño |
| :--- | :--- | :--- | :--- |
| L1 | **Única para el procesador** (dividida en caché de datos y caché de instrucciones) | **Mayor** | **Menor** |
| L2 | Por núcleo o compartida entre algunos núcleos | Intermedia | Intermedio |
| L3 | **Única para todo el procesador** (compartida entre todos los núcleos) | **Menor** | **Mayor** |

Esta organización sigue la jerarquía de memoria: **a mayor velocidad, mayor precio y menor tamaño**. 

### 4.- Memoria RAM

La **Memoria RAM** (*Random Access Memory*, memoria de acceso aleatorio) es la **memoria principal** en la arquitectura Von Neumann. Su nombre indica que está optimizada para guardar y acceder a los datos de forma **no contigua**. Es **volátil**, lo que significa que su contenido se **borra al apagar** el ordenador, por lo que se usa para almacenar instrucciones y datos **en ejecución**.

Físicamente, los módulos de RAM son tarjetas con *chips* de memoria soldados y se insertan en los zócalos de la placa base mediante pines o contactos metálicos.

Todas las memorias RAM modernas son **SD-RAM** (*Syncronic Dynamic-Random Access Memory*). Se denominan:
    - **Dinámicas:** necesitan **refrescar la información constantemente**.
    - **Síncronas:** el refresco se realiza **a golpe de reloj**. 

**Características de la memoria**
    - **Frecuencia o velocidad**: indica la cantidad de **ciclos por segundo** u operaciones elementales que realiza la memoria. Se mide en **MHz** o **GHz**.
    - **Ancho de Banda**: cantidad de datos que se pueden transferir en 1 segundo. Su cálculo es: `velocidad (MHz) × ancho de datos (bytes)`.
    **CL o CAS - Latencia**: número de **ciclos de reloj** necesarios para acceder a la **primera celda** en una lectura o escritura. Una **menor latencia** indica una **mejor memoria**.

**Evolución (DIMM SD-RAM)**

Cada nueva generación de memoria (DDR, DDR2, DDR3, DDR4) mejora a la anterior, ofreciendo mayor frecuencia y menor consumo y calor.

| Tipo | Contactos (PC) | Muescas | Lecturas por ciclo | Voltaje |
| :--- | :--- | :--- | :--- | :--- |
| DIMM-SDRAM | 168 | 2 | 1 | N/A |
| DIMM-DDR | 184 | 1 | 2 | 2,5 V |
| DIMM-DDR2 | 240 | 1 | 4 | 1,8 V |
| DIMM-DDR3 | 240 | 1 | 8 | 1,5 V |
| DIMM-DDR4 | 284 | 1 | 16 | 1,2 V |

:::caution Advertencia 
Aunque todas las DDR tienen una única muesca, su posición es diferente en cada generación. Insertar un tipo de memoria incorrecto en un zócalo puede dañar tanto la memoria como la placa base.
:::

**Dual, Triple y Cuádruple Canal**

La tecnología **Dual Channel** habilita **dos canales paralelos** de transmisión de datos entre la RAM y el controlador de memoria, lo que **dobla el ancho de banda** (la transferencia de datos).
    - **Requisito:** los dos módulos de memoria deben ser **idénticos** (fabricante, capacidad, velocidad y latencias).
    - **Instalación:** en las placas base, los zócalos suelen estar codificados por colores, y los módulos idénticos deben instalarse en las ranuras de **igual color** (siempre verificar el manual de la placa).

Existen placas con soporte para **triple** y **cuádruple canal** para mayores tasas de transferencia.

### 5.- Componentes de un computador

#### 5.1- Cajas de ordenador

Las cajas de ordenador se definen por su tamaño y forma (factor de forma), lo que determina su capacidad interna (número de bahías).

- **Minitorre o semitorre:** la diferencia es la altura, determinada por el número de **bahías de 5.25 pulgadas** (2 en minitorre, 4 en semitorre).
- **Sobremesa:** similares a las minitorre, pero con orientación **horizontal**. Requieren rotar los dispositivos extraíbles en el frontal.
-  **Barebone y slim:** cajas de **pequeño tamaño** que admiten pocos o ningún dispositivo interno, compensando con más conectores externos.

El panel trasero muestra directamente los conectores de la placa base, las tarjetas de expansión, la toma de corriente y la ventilación de la fuente de alimentación.

#### 5.2- Fuentes de alimentación

La función principal de la fuente de alimentación es **transformar la corriente alterna (AC)** de la red eléctrica (ej. 230V en Europa) a **corriente continua (DC)** con voltajes inferiores que el *hardware* pueda usar.

| Voltaje de salida (DC) | Uso principal |
| :--- | :--- |
| +12V | Discos duros, ventiladores, disqueteras |
| +5V | Placa base y puertos USB |
| +3.3V | Algunas tarjetas de expansión y tipos de memoria |
| -12V / -5V | En desuso (antiguos puertos serie o tarjetas ISA) |

La característica más importante es la **potencia máxima** (medida en vatios, `W`), que debe ser suficiente para el *hardware* conectado (las fuentes estándar suelen ser de unos 500W. Una potencia insuficiente puede dañar el equipo.

**Conectores de la fuente de alimentación**

1.  **Alimentación a la placa base:**
    * **ATX v1.0 (20 pines):** conector principal.
    * **ATX v2.0 (24 pines / 20+4):** ampliación del conector principal, viene separado para compatibilidad con placas antiguas.
    * **Conector auxiliar 12V (P4):** proporciona energía adicional cerca del procesador. Evolucionó de 4 pines (P4) a 4+4 pines (8 en total) en la versión ATX v2.0.

2.  **Alimentación a dispositivos de almacenamiento:**
    * **Conector Molex:** para dispositivos IDE (discos duros, CD) y ventiladores adicionales.
    * **Conector Berg:** pequeño, para disqueteras (FDD) y primeros lectores de tarjeta (en desuso en fuentes modernas).
    * **Conector SATA:** conector moderno específico para discos duros y unidades ópticas SATA. (*Si una fuente antigua no tiene SATA, se pueden usar adaptadores Molex a SATA*).

3.  **Alimentación a tarjeta gráfica:**
    * **PCI-Express (6 u 8 pines):** conector para proporcionar **corriente adicional** a las tarjetas gráficas de alto rendimiento. No es obligatorio usarlo, pero es recomendable para que la tarjeta alcance su potencia máxima. 
 
#### 5.3.- Tarjetas gráficas
La **tarjeta gráfica** (o tarjeta de vídeo) es una tarjeta de expansión que tiene como función **adaptar los datos** enviados por el procesador para su **representación visual** en un monitor o proyector.

Actualmente, se conectan a la placa base a través del bus **PCI Express x16**. Muchas placas base incluyen una gráfica integrada, suficiente para el uso normal, pero no para un uso intensivo de gráficos.

**Componentes importantes**

| Componente | Siglas | Función |
| :--- | :--- | :--- |
| **GPU** | *Graphics Processing Unit* | Es el **procesador dedicado** de la tarjeta gráfica; realiza los cálculos necesarios para determinar los colores de cada píxel en la pantalla. |
| **Memoria de Vídeo** | GDDR (ej., GDDR5) | Almacena los datos de las imágenes a representar. **A mayor memoria, mejor será la resolución gráfica posible**. |
| **RAMDAC** | *Random Access Memory Digital-to-Analog Converter* | Convierte las señales digitales internas del ordenador a **señales analógicas** requeridas por algunos monitores. Está perdiendo importancia debido al auge de los monitores digitales. |

**Conectores al monitor**

Las tarjetas pueden tener salidas analógicas y/o digitales:
    - **VGA:** conexión **analógica**.
    - **DVI:** puede ser analógica (`DVI-A`), digital (`DVI-D`), o ambas (`DVI-I`).
    - **HDMI:** conexión **digital** más extendida. 

### 6.- Placa base

La **placa base** (*motherboard*) es el gran circuito impreso central del ordenador. En el contexto del modelo Von Neumann, equivale al conjunto de **buses de comunicación** que interconectan todos los demás componentes.

#### 6.1- Componentes de la placa base

![Imagen de una placa base](../../static/img/placa-base.jpg)

A continuación se detallan los principales componentes y conectores de la placa base, utilizando la imagen adjunta como referencia visual para facilitar el montaje y el mantenimiento: 

| ID | Componente | Uso |
| :---: | :--- | :--- |
| **1** | **Zócalo** | Se inserta el **microprocesador**. |
| **2** | **Chipset (Puente Norte)** | Gestiona la comunicación rápida. **Desaparece en placas actuales**. |
| **3** | **Chipset (Puente Sur)** | Gestiona la comunicación lenta. **Se mantiene en placas actuales**. |
| **4** | **Zócalos DIMM DDR2** | Ranuras para insertar los módulos de **Memoria RAM** (en este caso, tipo DDR2). |
| **5** | **Conector ATX (24 pines)** | Conector principal de la **fuente de alimentación** a la placa base. |
| **6** | **Conector 12V** | Conector adicional de alimentación para el **procesador** (antiguo conector de 4 pines, hoy 8 pines). |
| **7 y 8** | **Ranuras PCI Express 1x** | Ranuras pequeñas para tarjetas de expansión. |
| **9** | **Ranura PCI Express 16x** | Ranura larga y principal para la **tarjeta gráfica**. |
| **10** | **Ranuras PCI** | Ranuras para tarjetas de expansión antiguas. |
| **11** | **Conectores SATA** | Puertos de conexión de datos para **discos duros** y **unidades DVD SATA**. |
| **12** | **Conector IDE (40 pines)** | Conexión de datos para discos duros y DVD IDE (obsoleto en placas actuales). |
| **13** | **Conector FDD (34 pines)** | Conexión de datos para disqueteras antiguas (obsoleto en placas actuales). |
| **14** | **Panel frontal** | Conectores para los botones (*power*, *reset*) y LEDs de la caja del PC. |
| **15** | **Conector USB** | Puertos para conectar los **USB frontales** de la caja. |
| **16** | **Conector AAFP (Audio)** | Conector para el **Audio frontal** de la caja (auriculares y micrófono). |
| **17** | **CPU_FAN y PWR_FAN** | Conectores para el **ventilador del procesador** (CPU_FAN) y ventiladores adicionales de la caja (PWR_FAN). |
| **18** | **BIOS** | Chip que almacena el *software* de **inicio** que se ejecuta al encender el ordenador. |
| **19** | **Panel trasero ATX** | Conjunto de puertos que asoman por la parte trasera de la caja. |
| **20** | **Agujeros tornillos** | Puntos de sujeción para acoplar la placa base al chasis de la caja (mínimo de 6 tornillos). |

#### 6.2.- Panel trasero ATX

El **panel trasero ATX** es el conjunto de conectores integrados en la propia placa base que asoman por la parte trasera de la caja (introducido alrededor de 1995).

- **USB:** los puertos **USB 2.0** suelen ser **negros**, mientras que los **USB 3.0** son **azules**. Los USB amarillos permiten cargar dispositivos incluso con el PC apagado.
- **Monitores:** incluye conectores analógicos (**VGA**) y digitales (**DVI, HDMI, DisplayPort**).
    * **HDMI** se diseñó pensando en televisores.
    * **DisplayPort** (creado por AMD) se diseñó para ordenadores.
- **Conectores especiales:**
    * **Firewire (IEEE 1394):** utilizado históricamente para cámaras de vídeo de consumo.
    * **eSATA:** permite conectar discos duros SATA externos sin abrir la caja.
    * **SPIDF Out:** conexión de salida **óptica digital** para altavoces.

Se recomienda usar los puertos USB integrados del panel trasero para dispositivos externos (como *pendrives* o discos duros) en lugar de los frontales de la caja, ya que no hay *hardware* intermedio.

#### 6.3.- Zócalo de la placa base

El **zócalo** es el lugar en la placa base donde se inserta y fija el microprocesador, sobre el cual se monta el ventilador. Es crucial colocar el procesador correctamente, fijándose en las muescas, ya que es una de las partes más delicadas del montaje.

Existen varios tipos de zócalos, siendo los más comunes actualmente:
    - **ZIF** (*Zero Insertion Force*): utilizado principalmente por procesadores **AMD**. Los **pines** están en el **procesador**. El procesador se fija bajando una palanca.
    - **LGA** (*Land Grid Array*): utilizado por procesadores **Intel**. Los **pines** están en el **zócalo** (placa base) y el procesador tiene contactos planos. Permite mayor velocidad de buses.

#### 6.4.- Ranuras de expansión.

Las **ranuras de expansión** se utilizan para insertar tarjetas que **amplían** la funcionalidad del ordenador (gráficas, sonido, USB 3.0, etc.).

- **En desuso:** **AGP** (solo para tarjetas gráficas) y **PCI de 32 bits** (transferencia en paralelo).
- **Actuales (PCI Express):**
    * Utilizan **transferencia serie** (los datos se envían uno detrás de otro).
    * Existen con diferentes velocidades/longitudes (`1x`, `4x`, `8x`, `16x`). Una ranura **16x** es físicamente más larga y 16 veces más rápida que una 1x.
    * Se puede instalar una tarjeta de menor velocidad (ej. 4x) en una ranura más larga (ej. 16x), pero no al contrario.
    * Existen varias versiones (**PCI-Express 1, 2 y 3**) que se diferencian por las velocidades admitidas.

#### 6.5.- Chipset

El **chipset** es el componente más importante de la placa base, responsable de decidir las **capacidades** de la placa (tipo de procesadores, tipo y máximo de memoria RAM, ranuras y puertos admitidos).

Originalmente consistía en dos *chips* principales:
    1. **Northbridge (Puente Norte):** era responsable de conectar la **CPU** con los componentes de **alta velocidad** (Memoria RAM y Tarjeta Gráfica). **En las placas base actuales, ha desaparecido**, siendo sus funciones asumidas directamente por el microprocesador.
    2. **Southbridge (Puente Sur):** se encarga de la conexión de todos los **periféricos** y dispositivos de **almacenamiento** (SATA, IDE, USB, ranuras de expansión). Este componente **se mantiene** en las placas actuales. 

#### 6.6.- Conectores de almacenamiento

Los conectores de almacenamiento en la placa base permiten la conexión de discos duros, unidades de DVD y disqueteras mediante cables:
- **IDE** (40 pines): **en desuso**. Utilizado para antiguos discos duros y unidades ópticas. Se usa principalmente en tareas de mantenimiento.
- **FDD - Disquetera** (34 pines): **en desuso**. Para *floppy disks* (disqueteras antiguas).
- **SATA** (7 pines): el **estándar actual** para discos duros, SSD y unidades ópticas.

#### 6.7.- Conectores USB y Audio

La placa base incluye conectores internos de ampliación que permiten habilitar los puertos frontales y de audio de la caja:
- **Conectores USB:** cada conector interno de la placa base generalmente soporta **dos dispositivos USB**. Estos conectores se utilizan para conectar los puertos USB frontales de la caja. 
- **Conectores Audio:** el cable del audio frontal de la caja (auriculares y micrófono) se conecta al conector interno de la placa base (a menudo etiquetado como **AAFP**).

#### 6.8.- Panel frontal

El **Panel Frontal** es el conjunto de conexiones necesarias para que los botones (*power*, *reset*) y los indicadores LED de la caja funcionen. Estos cables soldados a los botones/LED de la caja deben conectarse a los pines correctos en la placa base.
- **Power SW:** botón de **encendido**.
- **Power Led (P-Led):** LED indicador de que el equipo está encendido.
- **Reset:** botón de **Reinicio**.
- **HDD-Led (IDE-Led):** LED que se enciende durante la actividad de lectura/escritura del disco duro.
- **Speaker:** conexión para el altavoz interno (bocina de la placa base).

Algunos fabricantes facilitan esta tarea mediante **conectores puente** que agrupan varios pines en un solo bloque.

#### 6.9.- La BIOS

La **BIOS** (*Basic Input/Output System*) es el **primer programa básico** que se ejecuta al encender el ordenador. Su objetivo inicial es ejecutar el **POST** (*Power-On Self-Test*), un proceso que **comprueba el *hardware*** esencial (procesador, memoria, etc.) antes de dar paso al arranque del sistema operativo desde el disco duro.

* **Programa Setup:** la BIOS incorpora un programa llamado **Setup** que permite al usuario modificar la configuración:
    * **Secuencia de arranque** (ej., CD antes que disco duro).
    * Fecha, hora y contraseñas de inicio.
    * Opciones avanzadas como **overclocking** (aumentar la velocidad del procesador, bajo riesgo).
* **Acceso:** para acceder al Setup, se debe pulsar una tecla específica (ej. **Esc, F2, Supr** o **DEL**) al iniciar el equipo.
* **Mantenimiento de datos:** los datos de configuración del usuario se mantienen mediante electricidad. Si el PC está desconectado, se utiliza la **pila CR2032**; si está gastada, aparecerá el mensaje "CMOS fail" y los datos de usuario se habrán borrado.
* **Actualización:** Hoy en día, la mayoría de las BIOS son **actualizables** (programables) desde la web del fabricante (a menudo usando un *pendrive*). Esta operación es delicada; un fallo o corte de luz puede dañar permanentemente la placa base.

#### 6.10.- Jumpers

Los **jumpers** son pequeños **pines** que sobresalen de la placa base y se unen mediante una pequeña **caperuza metálica** recubierta de plástico. Se utilizan para **fijar un parámetro variable** de funcionamiento de la placa.

Aunque las placas modernas traen pocos *jumpers* (1 o 2), se usan para tareas críticas como **borrar los parámetros de la BIOS** almacenados (restablecer a valores de fábrica).
    - *Ejemplo de borrado:* cambiar el *jumper* de la posición 'Normal' a 'Clear' (limpiar) y reiniciar, lo cual borra las contraseñas o configuraciones inaccesibles.

Algunos *jumpers* (como KBPWR o USBPW) pueden habilitar la función de **encender el ordenador** mediante el teclado o una señal a través del puerto USB, respectivamente. 

### 7.- Dispositivos de entrada y salida: memoria secundaria

La memoria secundaria (o auxiliar) es donde se leen y guardan los datos de forma permanente (discos duros, SSD, pendrives, etc.), ya que la CPU y la RAM solo manejan datos en tiempo de ejecución.

#### 7.1.- Características generales de los discos duros

| Característica | Descripción | Medida estándar |
| :--- | :--- | :--- |
| Capacidad | Espacio total para guardar datos | Terabytes |
| Velocidad de transferencia | Cantidad de datos transferidos por segundo | Megabytes por segundo |
| Tamaño físico | Dimensiones del disco | 3.5 pulgadas (PC de escritorio) o 2.5 pulgadas (portátiles) |
| Velocidad de rotación (*rpm*) | Vueltas que da el disco en un minuto | 7200 rpm (3.5 pulgadas) o 5400 rpm (2.5 pulgadas) |
| Tiempo de búsqueda | Tiempo para desplazar las cabezas de una pista a otra | Milisegundos |
| Latencia | Tiempo para que pase el sector requerido bajo la cabeza, una vez en la pista adecuada | Milisegundos |
| Tiempo de acceso | Tiempo total para colocarse sobre el sector a leer/escribir | Tiempo de búsqueda + Latencia |

#### 7.2.- Interfaces de conexión de discos duros   

| Interfaz | Tipo de transferencia | Velocidad y uso | Alimentación |
| :--- | :--- | :--- | :--- |
| IDE o PATA (*Parallel-ATA*) | Paralela |*Obsoleto. Conector de datos de 40 pines. | Conector Molex |
| SATA (*Serial-ATA*) | Serie | **Estándar actual**. Permite desconexión en caliente. | Conector de 15 pines |
| SCSI (*Small Computers System Interface*) | Paralela | Utilizado históricamente en **servidores**. Más rápido que PATA. | Conector Molex |
| SAS (*Serial Attached SCSI*) | Serie | **Opción actual para servidores**. Combina tecnología **SCSI** con interfaz **Serial** | Controladoras SCSI y discos SATA/SAS |

#### 7.3.- Comparativa HD y SSD

| Característica | HD | SSD |
| :--- | :--- | :--- |
| Estructura | Partes móviles (cabezas, pistas, sectores) | No mecánicos (tecnología *flash*) |
| Velocidad | Lento por retrasos mecánicos | Muy rápido (sin retrasos mecánicos) |
| Resistencia | Sensible a golpes y vibraciones | Muy resistente a golpes |
| Vida útil | Basada en fallos mecánicos | **Limitada** por un número máximo de ciclos de lectura/escritura (problema para servidores, no para PC) |
| Precio/Recuperación | Barato. Datos recuperables en caso de avería física. | Caro. Datos casi imposibles de recuperar en caso de avería. |
| Conexión | PATA/SATA | SATA, USB y PCI-Express |

:::info Estructura física del HD
La información se organiza en **pistas** y **sectores**. La velocidad es mayor en las pistas exteriores que en las interiores. 
:::

#### 7.4.- Conexiones USB. Pendrives.

La evolución de la interfaz USB ha supuesto un incremento drástico en la velocidad de transferencia, con el **USB 3.0** siendo 10 veces más rápido que el **USB 2.0**.

| Denominación | Velocidad |
| :--- | :--- |
| USB 1 | 1.5 MB/seg |
| USB 2.0 | 60 MB/seg |
| USB 3.0 (Gen 1) | 600 MB/seg |
| USB 3.1 (Gen 2) | 1200 MB/seg |

La especificación USB 3.0 ahora se denomina **USB 3.1 Generación 1**.

**Pendrives y Memoria Flash**

Los *pendrives* son unidades de **memoria no volátil** (tecnología *flash*), siendo tecnológicamente similares a las unidades SSD.
    - **Velocidad:** existen grandes diferencias de velocidad y calidad entre modelos. Es común que los *pendrives* no alcancen la velocidad máxima teórica de la interfaz del puerto.
    - **Recomendación de compra:** es aconsejable comprar memorias **USB 3.0** ya que, incluso si se conectan a un puerto USB 2.0 antiguo, su mejor calidad interna garantiza una velocidad de transferencia más rápida que un *pendrive* 2.0 de gama baja.
    - **Recuperación de datos:** en caso de avería, la **recuperación de datos es difícil**.

:::tip
Al comprar cualquier dispositivo de almacenamiento (incluidas las tarjetas de memoria), no hay que fijarse solo en el precio, sino **comparar las velocidades reales** de transferencia, ya que varían mucho entre dispositivos de la misma especificación.
::: 

### 8.- Dispositivos de entrada y salida: periféricos

Los **periféricos** son unidades externas que se conectan al ordenador a través de los buses de entrada/salida para integrarse en el sistema. Ejemplos habituales incluyen el teclado, ratón, monitor, impresora y conexión de red.

Según su función, se clasifican en:
    - **Unidades de entrada:** introducen información o datos desde el exterior a la memoria central (ej., teclado, escáner).
    - **Unidades de salida:** sacan los datos o resultados de los procesos al exterior de forma comprensible para el usuario (ej., monitor, impresora).
    - **Unidades de entrada/salida:** se utilizan para ambos flujos (ej., tarjetas de red, que envían y reciben tráfico).

**Impresora**

Dispositivo de salida que transfiere información del ordenador al papel. Puede conectarse por USB o red.

| Tipo de impresora | Tecnología | Uso |
| :--- | :--- | :--- |
| Matricial | Impacto sobre una cinta | La más económica. Solo se utiliza con papel continuo. |
| Inyección de tinta | Tinta líquida | Ofrece los mejores resultados en color, pero es la más cara por consumibles |
| Láser | Tóner | Más barata para la impresión de **grandes cantidades** de papel con resultados muy aceptables |

**Monitor**

Dispositivo de salida que muestra la imagen proporcionada por la tarjeta gráfica.
    - **Tamaño:** se mide por la longitud de su **diagonal** en **pulgadas**.
    - **Tamaño del punto (*Dot Pitch*):** distancia entre dos puntos del mismo color. A **menor** tamaño del punto, **mejor definición** y mayor nitidez de la imagen (el estándar es 0.24 mm).
    - **Resolución máxima:** número total de píxeles (puntos) que la pantalla puede representar (píxeles horizontales x verticales). A mayor resolución, mejor calidad de imagen.
    - **Conexión:** puede ser **analógica** (VGA) o **digital** (HDMI, DVI).
    - **Clasificación:** la tecnología ha evolucionado de **CRT** (Tubo de Rayos Catódicos, en desuso) a **LCD** (Pantalla de Cristal Líquido) y, actualmente, a **LED** (más usados por su bajo consumo).

**Escáner**

Dispositivo de entrada que convierte un documento de papel (señal analógica) a un lienzo digital (datos binarios).
    - **Proceso:** el documento de papel (medidas en cm) se convierte en un documento digital (medidas en píxeles).
    - **Factor de conversión:** se utiliza el parámetro **ppp** (píxel por pulgada), donde 1 pulgada equivale a 2.54 cm.
    - **Cálculo de píxeles:** dimensiones en pulgadas x ppp.
    - **Ejemplo:** escanear una foto de 6 x 4 pulgadas a 300 ppp resulta en una imagen de 1800 x 1200 píxeles (aprox. 2 megapíxeles).

:::note Observación
Las cámaras fotográficas tienen muchos megapíxeles no porque se necesite para ver en pantalla, sino para asegurar una **buena resolución para imprimir o retocar** la foto. 
:::

### 9.- Montaje del ordenador

Antes de manipular los componentes de un computador, es crucial aplicar medidas de seguridad para proteger tanto al técnico como al *hardware* electrónico.

**Prevención de riesgos laborales. Medidas de seguridad.**

1.  **Seguridad física:** siempre **desconecta la alimentación** eléctrica antes de instalar o desinstalar cualquier componente del equipo.
2.  **Electricidad Estática:** la electricidad estática puede dañar gravemente los componentes electrónicos, aunque no es peligrosa para las personas. Para prevenirla:
    - Utiliza una **pulsera antiestática** conectada a una toma de tierra (o a una chapa metálica de la caja).
    - En su defecto, **toca la caja metálica** constantemente para descargarte.
3.  **Herramientas:** mantén las herramientas necesarias a mano y bien ordenadas.

**Montaje de un PC**

1.  **Montar placa base**
        - Colocar los separadores necesarios en la caja.
        - Atornillar la placa base a la caja.
2.  **Montar procesador y ventilador en la placa base**
        - Insertar el microprocesador en su zócalo.
        - Aplicar pasta térmica sobre el microprocesador.
        - Colocar el ventilador encima del procesador y conectar su cable al conector *CPU_Fan*.
3.  **Instalar RAM**
        - Insertar los módulos de RAM, asegurándose de que son la **versión DDR correcta** y que quedan bien encajados.
4.  **Conectar conectores de alimentación de la fuente de alimentación a la placa base**
5.  **Conectar panel frontal, USB y audio delanteros en la placa base.**
6.  **Instalar dispositivos de almacenamiento con sus 2 conexiones: datos y alimentación**
7.  **Instalar posibles tarjetas de expansión**

:::tip Recomendación
Se aconseja leer completamente el **manual de la placa base** para entender la ubicación precisa y las especificaciones de todos los conectores y *hardware* a conectar.
:::

## UD3.- Explotación de Windows. Particiones de discos.

![Esquema Unidad 3 Sistemas Informáticos](../../static/img/sistemas-informaticos-unidad-3.jpg)

### 1.- Versiones de Windows. Ventanas *Propiedades equipo* y *Administrar*.

Esta sección introduce las características de **Windows 10** y las distintas versiones disponibles, destacando la importancia de elegir la versión adecuada para las necesidades del usuario.

#### 1.1.- Versiones de Windows. Ciclo de vida.

**Versiones principales de Windows 10**

| Versión | Uso | Funciones |
| :--- | :--- | :--- |
| Windows 10 N | Tablets y móviles con procesador *ARM* | No compatible con procesadores Intel/AMD |
| Windows 10 Home | Mercado doméstico | Es la versión más común que se vende preinstalada |
| Windows 10 Pro | Empresas y profesionales | Conexión a dominio (para trabajar con Windows Server), Cifrado con Bitlocker y EFS, establecimiento de políticas de grupo, escritorio de acceso remoto y soporte para hasta 256 procesadores |
| Windows 10 Enterprise | Grandes empresas | Versión con ligeras mejoras sobre Pro, adquirida mediante licencias corporativas o por volumen |

>*ARM es una arquitectura de 32 bits de baja potencia y bajo consumo.*

**Requisitos mínimos de hardware**

Para una experiencia de usuario fluida, se recomienda un *hardware* superior a estos mínimos:
    - **Procesador:** 1 GHz o superior (x86 o x6).
    - **Memoria RAM:** 1 GB (32 bits) o 2 GB (64 bits).
    - **Espacio en disco:** 16 GB (32 bits) o 20 GB (64 bits).
    - **Gráficos:** DirectX 9 con controlador WDDM 1.0.

**Ciclo de vida de Windows**

El **ciclo de vida** define el tiempo durante el cual un sistema operativo recibirá **soporte técnico** de Microsoft. Una vez que finaliza, se requiere una migración a un sistema más moderno.

#### 1.2.- *Propiedades del equipo* y *Administrar*

Para obtener detalles de la versión de Windows 10 instalada y las especificaciones básicas del *hardware*, se accede a la ventana **Propiedades del equipo**. Una vez dentro, se puede ver información como: 
    1.  **Versión de Windows 10** instalada (ej., Home, Pro, Enterprise).
    2.  Información esencial del *hardware*: **tipo de procesador** y cantidad de **RAM** instalada.
    3.  **Nombre de la máquina** (el identificador de red del equipo).
    4.  Estado de la **activación de Windows**.
    5.  Acceso directo al **Administrador de dispositivos** (para ver y gestionar el *hardware*).
    6.  Acceso a la **Configuración avanzada del sistema**.

### 2.- Estructura lógica de un disco duro: particiones y sistemas de archivos

Para tener un control total de la instalación de Windows, es necesario conocer cómo se guarda la información en los discos duros.

#### 2.1.- Herramientas para crear particiones

Existen herramientas internas del sistema operativo y herramientas externas para gestionar particiones:

**Herramientas internas:**
    - **Microsoft:** se utiliza `diskpart` (en modo comando) junto con la herramienta gráfica **Administrador de discos**.
    - **Unix/Linux:** se utiliza **`fdisk`**.

**Herramientas externas:**
    - No pertenecen al núcleo del sistema operativo. Las más conocidas son **GParted** (*software libre*) y **Easeus Partition Master** (*software propietario*). Sus ventajas son que permiten crear particiones tanto de Windows como de Linux y además ofrecen funcionalidades avanzadas como **redimensionar** (cambiar el tamaño) y **mover** particiones.

**Administrador de discos de Windows**

El Administrador de discos muestra la estructura completa del disco, incluyendo particiones visibles y ocultas y el **espacio no asignado**.

- **Creación de particiones:** para crear una partición, se selecciona el **espacio no asignado**, se usa el menú contextual y se elige *Nuevo volumen simple*, especificando el tamaño, una letra de unidad y un sistema de archivos (ej. NTFS).
- **Montaje de particiones:** cuando se crea una partición y se le asigna una letra, se dice que "se ha montado la partición".
- **Resolución de conflictos de letras:** si la letra de unidad asignada a la nueva partición entra en conflicto con un recurso de red ya existente, se debe usar el Administrador de discos para cambiar la letra de la unidad y seleccionar una libre.

**GParted**

GParted es una popular herramienta externa (comúnmente incluida en distribuciones Linux como Ubuntu) que se puede utilizar para gestionar particiones de cualquier sistema operativo arrancando desde un CD o *pendrive*.

#### 2.2.- Particiones: BIOS-MBR

El esquema **BIOS-MBR** es el particionamiento tradicional utilizado desde los primeros PC.

El **MBR (*Master Boot Record*)** es el sector de arranque que ocupa los **primeros 512 bytes** del disco. La limitación estructural del MBR fuerza la siguiente clasificación de particiones:
    - **Partición primaria:** máximo **cuatro** por disco. Pueden contener datos o un sistema operativo.
    - **Partición activa o arrancable:** solo puede haber **una** y **debe ser una partición primaria**. Es la que contiene el sistema operativo.
    - **Partición extendida:** sSe crea para superar el límite de cuatro particiones primarias (sustituye a una de ellas). **Solo puede haber una** por disco MBR.
    - **Particiones lógicas:** Se crean **dentro** de la partición extendida. En Windows, el límite es **23**. No pueden ser particiones activas.

**Función del MBR:** al arrancar, la BIOS busca el disco configurado, lee el MBR, identifica la partición **activa** y transfiere el control a esa partición para iniciar el SO.

> **Observación:** Cuando se elimina una partición, solo se modifican los 512 bytes del MBR para indicar que el espacio está libre; los datos del disco no se borran.

#### 2.3.- Particiones: UEFI-GPT

El esquema **UEFI-GPT** es el método moderno de particionamiento, introducido con Windows 8 y diseñado para superar las limitaciones del MBR.

- **UEFI (*Unified Extensible Firmware Interface*)**: interfaz de *firmware* que sustituye a la BIOS tradicional. Para el usuario, actúa como una **BIOS gráfica** que admite el uso del ratón.
- **GPT (*GUID Partition Table*)**: esquema de particionamiento asociado a UEFI, que ofrece importantes ventajas sobre MBR:

    | Característica | GPT | MBR |
    | :--- | :--- | :--- |
    | Límite de particiones | Hasta **128 particiones** primarias | Máximo 4 particiones primarias |
    | Tamaño máximo por partición | Hasta **256 TB** | Máximo 2 TB |
    | Tipo de particiones | Solo particiones **primarias** | Primarias, extendidas y lógicas |

**Reglas UEFI-GPT**

* **Requisitos:** un sistema operativo en un disco GPT **solo puede arrancar con UEFI**. Además, generalmente solo admite sistemas operativos de **64 bits**.
* **Compatibilidad:** para trabajar con sistemas antiguos, la configuración UEFI incluye un **modo de compatibilidad** llamado **Legacy** (que simula el modo BIOS-MBR).
* **Sectores:** GPT utiliza 34 sectores al inicio del disco, mientras que MBR solo usa 1 sector.
* **Discos dinámicos:** GPT permite crear **discos dinámicos** (particiones que usan espacio no contiguo o se extienden por varios discos), algo no posible con los discos básicos de MBR.
* **Inicialización:** antes de crear particiones en un disco nuevo, hay que **informar al sistema** si se desea iniciar como MBR o GPT. GPT no se admite en dispositivos extraíbles.

#### 2.4.- Sistemas de archivos. Formato de particiones.

El **sistema de archivos** (o tipo de formato, ej. FAT32, NTFS) es el método lógico que se aplica a una partición para organizar y gestionar los datos. Al **formatear** una partición, se crea una tabla al inicio (como la tabla FAT) que permite localizar los archivos posteriormente.

**Clúster (unidad de asignación):** es la **unidad lógica más pequeña** de almacenamiento de un disco. Está compuesto por un conjunto contiguo de **sectores** (donde 1 sector = 512 bytes, la mínima unidad física).
    - **Regla de almacenamiento:** un clúster **no puede** almacenar información de dos archivos distintos. Si un archivo es más pequeño que el clúster, el espacio restante se **pierde** (fragmentación interna).
        - *Ejemplo:* un archivo de 10 bytes ocupa un clúster entero, que puede ser de 4 KB (4096 bytes), desperdiciando 4086 bytes.
    - **Tamaño:** suele ser potencia de 2 (512 bytes, 1 KB, 2 KB, 4 KB, etc.). El tamaño del clúster es un compromiso entre el rendimiento y el desperdicio de espacio:

    | Clúster | Ventaja | Desventaja |
    | :--- | :--- | :--- |
    | Pequeño (ej. 512 bytes) | Menor fragmentación | Menor velocidad, ya que un archivo grande se divide en más clústeres no contiguos, obligando a mover más los cabezales del disco |
    | Grande (ej. 64 KB) | Mayor velocidad de lectura/escritura | Mayor fragmentación |

**Sistemas de archivos de Microsoft (Windows)**

| Formato | Uso | Limitaciones y ventajas |
| :--- | :--- | :--- |
| FAT16 | Medios de almacenamiento muy pequeños o antiguos | Obsoleto |
| FAT32 | Medios extraíbles | Mayor compatibilidad con distintos sistemas operativos | Límite crucial: 4 GB por archivo |
| exFAT | Medios extraíbles | Creado para solucionar la limitación de FAT32. Admite archivos mayores a 4 GB. |
| NTFS | Estándar actual para todas las particiones internas de Windows | Mayor seguridad, mayor fiabilidad y límites máximos de archivo/partición muy superiores |

### 3.- Arranque dual de Windows. Gestor de arranque.

El **arranque múltiple** o **arranque dual** (*dual boot*) es una configuración que permite instalar dos o más sistemas operativos, generalmente en distintas particiones, en el mismo equipo. Al iniciar, el usuario es presentado con un menú para elegir el SO que desea cargar.

#### 3.1.- Instalación de segundo sistema operativo Windows en un equipo

El proceso de instalación de un segundo Windows en el mismo equipo es idéntico al de una instalación normal, pero requiere una selección crucial en la etapa de particionamiento.

**Opciones de instalación:**
    - **Actualización:** sustituye el Windows instalado, manteniendo archivos y configuraciones del usuario. **Resultado:** solo queda un nuevo Windows. (*Solo se puede actualizar desde SO compatibles, ej. de Windows 7 a Windows 10*).
    - **Personalizada:** permite instalar un nuevo SO, ya sea borrando el anterior o dejando **instalados dos sistemas operativos** (arranque dual).

**Proceso para arranque dual:**

1.  Seleccionar la opción **Personalizada** en la instalación.
2.  **Preparar la partición:** crear una partición **libre y disponible** para el segundo Windows. Si se desea usar espacio que contiene datos, la partición debe ser eliminada.
3.  **Selección de partición:** seleccionar el **espacio libre** deseado (ej. 30 GB) para la instalación del nuevo Windows.
4.  El proceso de instalación continúa con los mismos pasos que el primer SO.

Una vez instalado el segundo SO, al iniciar el equipo, aparece una ventana del **gestor de arranque** para seleccionar qué sistema operativo arrancar.

- En el menú, los sistemas operativos se diferencian por el **volumen** del disco en el que están instalados.
- El usuario tiene un tiempo límite (por defecto 30 segundos) para elegir qué SO quiere iniciar.

#### 3.2.- Configuración de gestores de arranque

El proceso de arranque de un PC depende de su *firmware* (BIOS o UEFI) y del esquema de particionamiento (MBR o GPT).

**Proceso de arranque**

* **BIOS-MBR:** el programa POST verifica el *hardware*, la BIOS busca el dispositivo de arranque, accede al sector **MBR** del disco, lee la **partición activa**, y ejecuta el código de arranque inicial de esa partición para cargar el SO.
* **UEFI-GPT:** el *firmware* UEFI inicializa los dispositivos y cede el control a los **servicios de arranque de UEFI**, que localizan un gestor de arranque o un cargador de sistema en el disco para iniciar el SO.

**Estudio del arranque de Windows 10**

Al instalar Windows 7 o posterior, se crea automáticamente una partición de sistema que es crucial para el arranque dual:

- **Partición *Reservado para el sistema*:** partición separada (inicialmente 550 MB en Windows 10) que contiene los archivos necesarios para el gestor de arranque, utilidades de recuperación y seguridad.
    - Esta partición es la **Partición Activa** y **Partición de Sistema**.
    - Windows **la protege** especialmente: no le asigna letra de unidad y **no aparece** en el Explorador de Windows.
- **Partición de Arranque:** es donde está **instalado el sistema operativo** (ej. la partición de 50 GB donde reside Windows).
- **Regla de Instalación Dual:** solo puede existir **una partición de sistema** por equipo. Las instalaciones subsiguientes de Windows la reconocen y simplemente **actualizan su contenido** para incluir las nuevas opciones en el menú de arranque.

> **Importante:** una partición donde Windows no está arrancado (ej. la partición del primer Windows) es considerada solo una **partición de Datos** y puede ser formateada o eliminada. Sin embargo, la partición de arranque actual (C:) no permite ser eliminada ni formateada.

**Configuración del gestor de arranque `bcd`**

Desde Windows Vista, el proceso de inicio se basa en los ficheros de configuración de arranque:
    - **`bootmgr`:** es el primer archivo que se ejecuta en la partición de sistema (tras ser leído el MBR).
    - **`bcd.log` (*Boot Configuration Data*):** es el **gestor de arranque** propiamente dicho. El `bootmgr` lo lee para obtener las entradas de los sistemas operativos disponibles.
        - Si hay **más de una entrada**, muestra el menú de arranque.
        - Si hay **solo una entrada**, el gestor no se muestra y el inicio procede directamente con `winload.exe`.

**Programa `bcdedit`**
    - Herramienta oficial de Windows para **editar el archivo `bcd.log`**.
    - Permite eliminar, editar o agregar entradas al menú de arranque, incluso configurando la carga de sistemas operativos como GNU/Linux.
    - Útil para **cambiar la descripción** por defecto de los sistemas operativos.
    - Existe una utilidad gráfica no oficial y gratuita llamada **EasyBCD** con propósitos similares.

:::info Otros gestores de arranque y compatibilidad
**GNU/Linux** utiliza el gestor de arranque **GRUB**, que sí reconoce las particiones de Windows sin configuración adicional.
:::

:::tip Recomendaciones para el arranque dual
1.  **Orden de Instalación (Microsoft):** se deben instalar los sistemas operativos Windows por **orden de antigüedad** (primero el más antiguo). Si se instala Windows 7 después de Windows 10, los archivos más antiguos de Windows 7 pueden sobrescribir e inutilizar el gestor de arranque de Windows 10.
2.  **Windows y Linux:** si se desea instalar ambos, se debe instalar **Windows primero**. Luego, al instalar Linux, el gestor **GRUB** reconocerá la instalación de Windows y creará la entrada correspondiente. 
:::

### 4.- Terminal de comandos de Windows

La terminal de comandos de Windows (o **Símbolo de sistema**) es una interfaz de texto que permite realizar las mismas tareas de gestión de archivos (crear, copiar, mover, eliminar, renombrar) que se hacen gráficamente con el "Explorador de Windows".

#### 4.1.- Primeros comandos

* **Acceso:** se abre ejecutando `cmd` o seleccionando "Símbolo de sistema" en el menú de Windows.
* **Directorios y unidades:** un directorio es una zona para almacenar ficheros. Cada partición lógica (ej. `C:`) es la **raíz** de un **árbol de directorios** distinto.
* **Ruta de archivo:** indica la ubicación completa del archivo.
* **Prompt del sistema:** indica la ruta actual. Espera una orden y se devuelve cuando el comando ha finalizado.
* **Sintaxis:** las órdenes tienen la forma `Comando [Parámetros] [Opciones o modificadores]`.
* **Ejecución de ficheros:** los archivos ejecutables (`.exe`, `.com`, `.bat`) se ejecutan tecleando su ruta y nombre. Si la ruta tiene espacios, debe ir entre comillas (ej. `"C:\Program Files\..."`).
* **Sensibilidad:** Windows **no diferencia** mayúsculas de minúsculas en nombres de archivo, pero sí permite el uso de **tildes**.
* **Ayuda:** se puede solicitar ayuda sobre cualquier comando usando `/?` o `help comando`. El símbolo `|` se usa para filtrar la salida de un comando con otro (ej. `comando /? | more` para ver la ayuda pantalla a pantalla).

**Comandos esenciales y de gestión de particiones**

| Comando | Función | Notas |
| :--- | :--- | :--- |
| `help` | Muestra todos los comandos disponibles | `comando /?` o `help comando` muestra la ayuda específica |
| `ECHO` | Repite un mensaje en pantalla | `ECHO Mensaje` |
| `CLS` | Limpia la pantalla | |
| `VER` | Muestra la versión de Windows | |
| `DATE` | Muestra o cambia la fecha actual | Usar `/T` para solo mostrar la fecha sin pedir entrada |
| `TIME` | Muestra o cambia la hora actual | Usar `/T` para solo mostrar la hora sin pedir entrada |
| `LABEL` | Crea o modifica la **etiqueta** de una partición | `LABEL [unidad:]` |
| `MORE` | Filtra la salida de un comando para mostrarla **pantalla a pantalla** | |
| `FORMAT` | **Formatea** una partición | `/FS:sistArch` especifica el sistema de archivos (ej., NTFS) |
| `DEFRAG` | **Desfragmenta** la unidad | No es necesario en discos SSD/pendrive por su acceso aleatorio optimizado |
| `CHKDSK` | **Comprueba el disco**. Da información de unidades de asignación libres/defectuosas. | `/F` corrige los errores encontrados y guarda archivos dañados en la carpeta `found000`. Se ejecuta automáticamente tras apagados incorrectos. |

#### 4.2.- Comandos para directorios y ficheros

Esta sección detalla la gestión de archivos y directorios mediante la terminal de Windows, incluyendo la navegación por rutas y la manipulación de atributos.

**Estructura base y rutas**

Tras la instalación de Windows, la raíz (`C:\`) contiene carpetas principales: `Windows` (archivos del sistema), `Program Files` (programas de usuario por defecto) y `Users` (contiene carpetas individuales de usuario).

- **Rutas absolutas:** empiezan desde la **raíz** y siempre se escriben igual, independientemente de dónde esté situado el usuario.
- **Rutas relativas:** empiezan a partir del **directorio activo** actual, por lo que su sintaxis cambia según la ubicación.
- **Directorio actual (`.`):** representa el directorio en el que estás.
- **Directorio padre (`..`):** representa el directorio inmediatamente superior.

**Comandos para directorios**

| Comando | Alias | Función | Notas |
| :--- | :--- | :--- | :--- |
| `CD` | | Cambiar de directorio activo | `CD ..` (sube al padre), `CD \` (va a la raíz) |
| `DIR` | | Visualiza directorios y ficheros | `/s` (incluye subdirectorios), `/p` (pausa al llenar la pantalla) |
| `MKDIR` | `MD` | Crea un nuevo directorio | |
| `RMDIR` | `RD` | Borra un directorio | `/s` (borra aunque no esté vacío, incluyendo subdirectorios), `/q` (borrado silencioso, sin confirmación) |
| `XCOPY` | | Copia directorios con todos sus ficheros | `/E` (copia todos los subdirectorios, incluso los vacíos, realizando una copia idéntica) |

**Comandos para ficheros**

| Comando | Función | Notas |
| :--- | :--- | :--- |
| `COPY` | Copia ficheros | Se usa cuando se copian solo ficheros |
| `DEL` | Borra ficheros | `/S` (borra ficheros en subdirectorios) |
| `REN` | Renombra un fichero | Solo se indica el nombre antiguo y el nombre nuevo |
| `MOVE` | Mueve un fichero a otro directorio | Permite mover y renombrar el fichero simultáneamente |
| `TYPE` | Muestra en pantalla el contenido de un fichero de texto plano | |

**Atributos de archivos. Comando `ATTRIB`**

El comando `ATTRIB` se utiliza para ver o modificar las características de un fichero o directorio. Los signos `+` añaden el atributo y los signos `-` lo quitan.

| Atributo | Símbolo | Significado |
| :--- | :--- | :--- |
| Lectura | `R` | El archivo se abre en modo solo lectura, no se puede modificar ni borrar |
| Oculto | `H` | El archivo no se muestra al listar con `DIR` (ni por defecto en el Explorador de Windows) |
| Sistema | `S` | Archivo esencial del sistema (no se puede borrar fácilmente) |
| Archivo | `A` | Archivo de lectura y escritura normal |

> **Nota:** para borrar un archivo con el atributo `R`, `H` o `S` (o cualquier combinación) primero debe ser eliminado el atributo con el signo `-` (ej. `attrib -R archivo.txt`).

#### 4.3.- Direccionamiento y tuberías

El direccionamiento y las tuberías permiten manipular las entradas y salidas de los comandos más allá de la pantalla del terminal.

**Operadores de direccionamiento de salida**

Por defecto, la salida de un comando es la terminal (*salida estándar*). Los operadores de salida redirigen esta información hacia un archivo.

| Operador | Nombre | Función | Ejemplo |
| :---: | :--- | :--- | :--- |
| `>` | Redirección | Guarda la salida en un archivo. Si el archivo **ya existe, lo sobrescribe**. | `dir /S > archivo.txt` (crea o sobrescribe `archivo.txt` con el listado) |
| `>>` | Adición | Guarda la salida en un archivo. Si el archivo existe, la nueva información se añade al final del contenido existent | `date /T >> Listado.txt` (añade la fecha a `Listado.txt`) |

> **Potencia del terminal:** estos operadores permiten ejecutar varios comandos seguidos (`date /T > L.txt`, `time /T >> L.txt`, `dir /S >> L.txt`) para construir un archivo de informe organizado y completo.

**Tuberías y Filtros: `MORE`, `SORT` y `FIND`**

El concepto de **tubería** es introducir la información de salida de un comando en un canal (la tubería) para que sea procesada como entrada por un **filtro** (otro comando), en lugar de mostrarla en la pantalla.

El operador de tubería es el símbolo `|`.

| Comando (filtro) | Función | Modificadores |
| :--- | :--- | :--- |
| `MORE` | Filtra la información de salida para mostrarla **pantalla a pantalla** | Se pulsa `Intro` para avanzar |
| `SORT` | **Ordena** un conjunto de filas de texto | `/R` (Orden inverso o *Reverse*). `/+n` (Especifica la **columna** por la que ordenar). |
| `FIND` | **Busca una cadena de texto** y devuelve las líneas que la contienen | `/V` (Líneas que **no** contienen la cadena). `/C` (Solo cuenta el **número** de líneas). `/N` (Muestra las líneas con su **número de línea**). `/I` (Búsqueda **sin distinción** de mayúsculas/minúsculas). |

> **Ejemplo de tubería:** `attrib /s | more` (muestra los atributos de todos los archivos del árbol C, pausando cada vez que la pantalla se llena).

**Ficheros por lotes (BATCH) y *Scripts***

Un **fichero por lotes** (*batch file*) es un archivo de **texto plano** (extensión `.bat`) que contiene múltiples órdenes. Al ejecutarse, ejecuta una tarea tras otra **sin intervención del usuario**.

* **Ejemplo:** un fichero `lote.bat` puede contener los comandos `date /T`, `time /T`, y `dir /S` para generar un informe completo.
* **Comando `@echo off`:** se usa al inicio de un fichero `.bat` para desactivar la visualización de los comandos mientras se ejecutan.
* **Ejecución:** se ejecuta escribiendo el nombre del archivo en la terminal (`lote.bat`) o haciendo doble clic en el entorno gráfico.

> **Nota:** **PowerShell** es una consola moderna y más potente que `cmd` para la ejecución de scripts.

## UD4. Administración básica del sistema Windows

![Esquema Unidad 4 Sistemas Informáticos](../../static/img/sistemas-informaticos-unidad-4.jpg)

### 1.- Administración de usuarios y grupos

La administración de usuarios y grupos es fundamental para controlar el acceso y los permisos en Windows. Las **cuentas de usuario** están diseñadas para uso individual, mientras que los **grupos** facilitan la administración de múltiples usuarios a la vez.

Windows ofrece dos programas gráficos para gestionar usuarios y grupos:

1. **Cuentas de usuario:**
    - Accesible desde el **Panel de Control**.
    - Está disponible en **todas las versiones de Windows**.

2. **Usuarios y grupos locales:**
    - Accesible desde la herramienta **Administración de equipos**.
    - Es la herramienta **más completa** para administración.
    - **No está incluida en las versiones Home**, por lo que se utiliza por defecto en las versiones **Profesionales** o superiores.

Al instalar Windows, el sistema crea automáticamente varias cuentas integradas: **Administrador** e **Invitado**. Ambas cuentas integradas se encuentran **deshabilitadas** por defecto y deben habilitarse manualmente si se desean utilizar. Aparte de estas, se crea una cuenta de usuario solicitada durante la instalación (ej. "Pepito") que tiene **permisos de administrador**.

#### 1.1.- Cuentas de usuario en panel de control

La herramienta "Cuentas de usuario" en el Panel de Control permite gestionar las cuentas y definir sus niveles de privilegio:

- **Cuenta de usuario estándar:** posee **privilegios limitados**. Puede usar la mayoría de los programas, pero **no** puede instalar/desinstalar *software* o *hardware*, eliminar archivos esenciales del sistema, o cambiar configuraciones que afecten a otros usuarios.
- **Cuenta de administrador:** tiene el **máximo control** sobre el equipo. Solo debe usarse para tareas de administración que **afectan a otros usuarios** (ej., configuración de seguridad, instalación de *software* y acceso a todos los archivos).
- **Cuenta Invitado:** está deshabilitada por defecto y no aparece en la ventana principal de "Cuentas de usuario".

Para crear una nueva cuenta, se accede a **Administrar otra cuenta**, se selecciona **Crear una nueva cuenta**, se asigna un nombre y se elige el tipo de privilegio (`Estándar` o `Administrador`).

> **Eliminación:** Borrar una cuenta es **definitivo**. No se recuperan los permisos al crear una cuenta con el mismo nombre, ya que el sistema asigna un **nuevo SID** (*Security Identifier*) diferente al de la cuenta antigua.

#### 1.2.- *Usuarios y grupos* desde *Administración de equipos*

Esta herramienta, también accesible ejecutando*`lusrmgr.msc`, es la opción preferida y más completa para administrar usuarios y grupos en versiones de Windows **no Home**.

Los **grupos** simplifican la administración al permitir asignar permisos a un conjunto de usuarios en lugar de hacerlo individualmente (ej. compartir una carpeta a un grupo entero).

**Tipos de grupos:**
    - **Grupos creados por el administrador.**
    - **Grupos integrados:** cuentas de grupo creadas por Windows.
    - **Grupos especiales (de seguridad):** grupos implícitos basados en la actividad que no aparecen explícitamente pero pueden recibir permisos.

> **Diferencia clave:** El grupo `Usuarios avanzados` tiene la capacidad adicional de **instalar aplicaciones**, a diferencia del grupo `Usuarios` estándar.

Las propiedades de un usuario se gestionan en varias pestañas:

- **Solapa "General":**
    - Define el nombre completo y la descripción.
    - **Opciones de contraseña:**
        - `El usuario debe cambiar la contraseña en el siguiente inicio de sesión`
        - `El usuario no puede cambiar la contraseña`
        - `La contraseña nunca caduca`
    - Permite **deshabilitar o habilitar** la cuenta.

- **Solapa "Miembro de":**
    - Muestra los grupos a los que pertenece el usuario.
    - Permite **agregar o eliminar** al usuario de grupos.

#### 1.3.- UAC (User Account Control, Control de Cuentas de Usuario)

El **UAC (Control de Cuentas de Usuario)** es una característica de seguridad de Windows que lanza una **alerta de seguridad** cada vez que se intenta realizar una acción en el sistema que requiere privilegios de administrador (ej. instalación de programas). El UAC busca prevenir cambios no autorizados por *software* malicioso o por errores accidentales del usuario.
- La alerta es configurable y se gestiona en el panel **Cuentas de usuario**.  Existen **cuatro niveles** de configuración, desde el más restrictivo (**notificar siempre**) hasta el más permisivo (**no notificar nunca**). 

### 2.- Seguridad local. Permisos locales o NTFS.

La **seguridad local** permite a los usuarios proteger sus archivos y carpetas en un mismo PC, controlando el acceso de otros usuarios. Para que esta funcionalidad esté disponible, la partición de disco **debe ser de tipo NTFS**.

#### 2.1.- Solapa *Seguridad*

Si la partición es FAT32, se puede convertir a NTFS sin perder datos mediante el comando: `convert unidad: /fs:ntfs`.

- **Solapa Compartir:** permisos aplicados cuando se accede al recurso a través de la red (desde otro equipo).
- **Solapa Seguridad:** **permisos locales** o **NTFS** que se aplican a los usuarios cuando acceden al recurso desde el mismo equipo.

#### 2.2.- Modificar permisos estándar. Botón editar de la solapa *Seguridad*.

Los permisos se conceden a **usuarios y grupos**. Por defecto, se **heredan** de la carpeta padre. El **propietario** del objeto (quien lo creó) y los **administradores** pueden modificar estos permisos (un administrador puede convertirse en propietario de cualquier objeto).

Al pulsar **Editar** en la solapa Seguridad, se accede a la modificación de los permisos estándar:

**Permisos estándar (de menos a más potentes)**

| Permiso | Aplicación en carpetas | Aplicación en archivos |
| :--- | :--- | :--- |
| Mostrar el contenido de la carpeta | Permite ver nombres de archivos y subcarpetas (solo en carpetas) | N/A |
| Lectura | Incluye `Mostrar contenido` más ver atributos, propietarios y permisos | Permite leer el archivo, ver atributos y permisos |
| Lectura y ejecución | Incluye `Lectura` más la capacidad de navegar por la carpeta y ejecutar programas | Permite ejecutar programas |
| Escritura | Incluye `Lectura y ejecución`, crear archivos/subcarpetas y cambiar atributos | Permite cambiar el contenido y cambiar atributos |
| Modificar | Incluye `Escritura` más la capacidad de borrar la carpeta | Permite borrar el archivo |
| Control total | Incluye `Modificar` más cambiar permisos y cambiar propietario | Incluye `Modificar` más cambiar permisos y cambiar propietario |

:::info ¿Cómo calcular los permisos de un objeto?
Cuando un usuario pertenece a varios grupos con permisos configurados, se aplican dos reglas fundamentales:
    1.  **Regla de denegación:** si el **usuario** o **cualquiera de sus grupos** tiene un permiso **denegado** explícitamente, el usuario **NO tendrá** ese permiso, incluso si otros grupos lo permiten.
    2.  **Regla de permisos acumulativos:** si **no** hay denegaciones explícitas, el usuario tendrá el **máximo** nivel de permiso permitido por el usuario mismo y por todos sus grupos.
:::

#### 2.3.- Botón *Opciones avanzadas* en solapa *Seguridad*

El botón **Opciones Avanzadas** accede a configuraciones de seguridad más detalladas:

- **Deshabilitar/Habilitar la Herencia:** la herencia de permisos de la carpeta padre está habilitada por defecto. Para modificar permisos heredados que aparecen sombreados, es necesario **deshabilitar la herencia**.
    - Al deshabilitar, se puede elegir entre:
        - **Convertir los permisos heredados en permisos explícitos:** se quita la herencia, pero se mantienen todos los permisos que existían.
        - **Quitar todos los permisos heredados.**
- **Cambiar el propietario del objeto.**
- **Permisos especiales:** en esta ventana, los permisos estándar se desglosan en **13 permisos especiales** (por ejemplo, `Lectura` se divide en `Leer datos`, `Leer atributos`, `Leer permisos`, etc.).
- **Solapa `Acceso efectivo`:** permite **consultar** los permisos reales y concretos que tiene un usuario o grupo específico en el objeto.

#### 2.4.- Recomendaciones y ejemplo final

Para evitar el caos en la administración de permisos locales (NTFS), es importante seguir estas pautas:
    - **Evitar la denegación:** se debe evitar en lo posible denegar permisos explícitamente.
    - **Priorizar grupos:** administrar permisos preferiblemente a **grupos**, en lugar de a usuarios individuales, para una gestión más eficiente.
    - **Priorizar carpetas:** administrar permisos preferiblemente en **carpetas**, en lugar de en archivos.

La estrategia ideal es aplicar el permiso más amplio a un grupo grande (ej. Lectura) y usar denegaciones solo mínimamente para **excluir** usuarios o grupos específicos.

El comportamiento de los permisos de un objeto (conservarlos o heredarlos) depende de si la acción es una copia o un movimiento, y si se realiza dentro de la misma partición NTFS o entre particiones distintas.

| Operación | Destino | Permisos resultantes | Analogía |
| :--- | :--- | :--- | :--- |
| Copiar (misma o diferente partición) | Siempre hereda | Se considera la creación de un **objeto nuevo** | Es una acción de escritura que crea un nuevo objeto en el destino |
| Mover (dentro de la misma partición) | Conserva los originales | Solo se **cambia la ruta** del objeto; no hay nueva escritura de datos | Es una operación rápida que solo actualiza el puntero en la tabla de archivos |
| Mover (entre diferentes particiones) | Hereda del destino | Se requiere una **escritura física** en la nueva partición | Equivale a Copiar y luego Borrar el original | 

### 3.- Registro de Windows. Directivas de grupo y seguridad local.

Windows 10 permite una gestión centralizada de la seguridad y configuración del sistema mediante **Directivas**. Estas reglas se configuran a través de consolas dedicadas:
    - **Directivas de seguridad local:** se utilizan para aplicar restricciones de seguridad sobre **cuentas de usuario y contraseñas**.
    - **Directivas de grupo local:** permiten configurar equipos (local o remota), **instalar o eliminar aplicaciones**, y **restringir derechos** de los usuarios.

#### 3.1.- Registro de Windows

El **Registro de Windows** es una base de datos jerárquica que almacena el **historial completo** y toda la configuración esencial del sistema operativo.
    - El Registro crece constantemente, lo que contribuye a que el ordenador **tarde más en arrancar** con el tiempo.
    - El Registro es muy delicado y **no debe tocarse** manualmente a menos que se sepa exactamente lo que se está haciendo, ya que la modificación incorrecta puede inutilizar el sistema.
    - Incluso tras desinstalar un *software*, su entrada permanece en el Registro, permitiendo al sistema saber que ya fue instalado previamente.

**Ejecución del editor de registro y copia de seguridad**

1.  **Editor:** el registro se edita manualmente con el programa `regedit`.
2.  **Copia de seguridad:** antes de cualquier modificación, es **crítico** realizar una copia de seguridad total. En el Editor de registro, se selecciona el total del equipo y se usa *Archivo / Exportar* para obtener un fichero de texto con extensión `.reg`.
3.  **Restauración:** en caso de error grave, se utiliza *Archivo / Importar* para restaurar el sistema.

Existen herramientas (ej. **RegClean, CCleaner, Regseeker**) que son más amigables que `regedit`. Su función es **borrar entradas innecesarias** e intentar corregir posibles errores de forma automática. **Regseeker**, por ejemplo, puede realizar una limpieza automática. Además, es útil para **desinstalar aplicaciones** que no ofrecen opción de desinstalación en *Agregar o quitar programas*. 

#### 3.2.- Directivas de grupo o política local

Las **Directivas de grupo local** son un conjunto de reglas que permiten gestionar de forma centralizada la configuración de seguridad y operación de un equipo Windows.
    - **Acceso:** se abre ejecutando el programa `gpedit.msc` como administrador.
    - **Función:** permite modificar el Registro de Windows de forma más amigable.
    - **Alcance (Sin Windows Server):** las políticas son **locales** y controlan solo los aspectos de la máquina actual (*grupo de trabajo*).

**Aplicación y configuración**

- **Tipos de configuración:**
    - **Configuración del equipo:** las directivas aquí definidas tienen **preferencia** en caso de conflicto.
    - **Configuración del usuario:** directivas aplicables a usuarios individuales.
- **Ejemplos de acciones:** deshabilitar el Administrador de equipos, modificar la configuración de red, obligar a un fondo de escritorio, o asignar *scripts* ejecutables al encendido/apagado/inicio/cierre de sesión.
- **Valores de directiva:**
    1.  **No configurada:** se aplica el criterio por defecto.
    2.  **Habilitada:** la directiva se pone en marcha.
    3.  **Deshabilitada:** se impide la ejecución de la directiva.

#### 3.3.- Directivas de seguridad local

Las **Directivas de seguridad local** se enfocan en aplicar restricciones de seguridad específicas sobre cuentas de usuario y contraseñas. Se puede acceder directamente ejecutando `SecPol.msc`, o a través del editor de directivas de grupo (`gpedit.msc`) navegando a *Configuración de seguridad*.

**Directivas de cuenta**

Se dividen en políticas de contraseña y políticas de bloqueo:

| Directiva | Categoría | Función |
| :--- | :--- | :--- |
| Exigir el historial de contraseñas | Contraseña | Impide que el usuario reutilice sus contraseñas más recientes |
| Complejidad de la contraseña | Contraseña | Obliga a las contraseñas a cumplir requisitos |
| Longitud mínima de la contraseña | Contraseña | Indica el número mínimo de caracteres requeridos |
| Vigencia máxima/mínima | Contraseña | Define el tiempo máximo antes de que la contraseña caduca y el tiempo mínimo que debe transcurrir antes de poder cambiarla de nuevo |
| Umbral de bloqueo de cuenta | Bloqueo | Número de intentos erróneos de contraseña permitidos antes de bloquear la cuenta |
| Duración del bloqueo de cuenta | Bloqueo | Tiempo que la cuenta permanecerá bloqueada |
| Restablecer el bloqueo | Bloqueo | Indica la frecuencia con la que el contador de intentos erróneos se pone a cero | 

### 4.- Herramientas del sistema. Herramientas administrativas.

#### 4.1.- Introducción

Aunque el aspecto de Windows varíe, las **herramientas integradas** son esencialmente las mismas; las diferencias radican en cómo acceder a ellas. En Windows 10:

- **Tecla Windows + R:** abre el cuadro **Ejecutar**, donde se puede escribir directamente el nombre del programa.
* **Menú Contextual de Inicio (clic derecho en el botón Inicio):** proporciona acceso rápido a herramientas administrativas importantes.

Las herramientas clásicas de gestión (`Panel de Control`, `Configuración`, y el menú contextual de `Equipo > Propiedades` y `Administrar`) siguen siendo importantes.

#### 4.2.- Cuotas de disco

La herramienta **Cuotas de disco** permite **limitar el espacio** que cada usuario puede utilizar para guardar datos en una partición.

Esta funcionalidad puede habilitarse de dos maneras:

1. **A través del Explorador de Windows**
    - Accede a **Propiedades** de la unidad (volumen de disco).
    - Selecciona la solapa **Cuota** y pulsa **"Mostrar la configuración de cuota"**.
    - Se marca **"Habilitar la administración de disco"** y se definen dos límites:
        * **"Limitar espacio en disco a..."**: El límite absoluto que no se puede superar.
        * **"Establecer el nivel de advertencia en..."**: El umbral en el que se notifica al usuario que se está acercando al límite.

2. **A través de Directivas de grupo**
    - Se accede a **Configuración del equipo / Plantillas administrativas / Sistema / Cuotas de disco**.
    - **Diferencia:** La cuota establecida por directiva es la suma de lo admitido entre **todas las unidades** del PC.

#### 4.3.- Desfragmentar y Comprobar unidad

La **desfragmentación** es el proceso que ayuda a reorganizar los archivos para que sus unidades de asignación (**clústeres**) queden **contiguas** en el disco:
    - Aumenta el rendimiento y reduce el tiempo que tarda el cabezal del disco duro en encontrar la información (ya que el archivo ya no está disperso).
    - La desfragmentación **no recupera espacio** perdido en los clústeres.
    - Se puede acceder buscando el programa o mediante `Propiedades de la unidad > Herramientas`. Por defecto, se ejecuta con una **programación semanal**, pero se puede anular.
    - La operación se puede ejecutar en la terminal con `defrag [unidad:]`.
    - Las unidades **SSD no se deben desfragmentar** porque están optimizadas para lectura aleatoria y tienen un número limitado de escrituras. Se debe anular la Ejecución programada en estos casos.

:::note Comprobar errores
La opción **Comprobar errores** (ubicada junto al desfragmentador en la solapa Herramientas) es la interfaz gráfica para ejecutar el comando `chkdsk /F [unidad:]`, que busca y repara errores en el sistema de archivos de la unidad.
:::

#### 4.4.- Programador de tareas

El **Programador de tareas** es una herramienta que permite **programar la ejecución automática** de aplicaciones, utilidades o archivos por lotes en momentos específicos.
    - Se accede desde la herramienta **Administración de equipos**.
    - Para cambiar las configuraciones que afectan al sistema, es necesario **iniciar sesión como administrador**. Si no se inició como administrador, solo se pueden modificar las tareas que afectan a la cuenta de usuario actual.

#### 4.5.- Protección del sistema. Puntos de restauración.

La **Protección del sistema** es una funcionalidad de Windows que permite **Restaurar el sistema** a un **punto anterior** de estabilidad, lo cual revierte la configuración y elimina los cambios realizados (*software* malintencionado, controladores defectuosos, errores de usuario, etc.) desde la creación de dicho punto. La protección del sistema viene **deshabilitada** por defecto porque los puntos de restauración consumen espacio en disco.

**Creación de un Punto de Restauración (manual)**
    1. Abrir **Propiedades** en "Equipo".
    2. Ir a la pestaña **Protección del sistema**.
    3. Pulsar **Configurar** y seleccionar **"Activar protección del sistema"**.
    4. Definir el **espacio máximo** de disco que pueden ocupar los puntos de restauración.
    5. Pulsar el botón **Crear**, asignar un nombre al punto y confirmar.

:::note Importante
Windows crea automáticamente puntos de restauración periódicamente, o cuando se instalan controladores o *software* considerados importantes. Si el espacio de disco asignado se llena, Windows **elimina el punto de restauración más antiguo**.
:::

#### 4.6.- Configuración. Actualización y seguridad.

La utilidad **Actualización y Seguridad** centraliza varias herramientas de mantenimiento y seguridad en Windows 10:

- **Windows Update:** servicio de actualizaciones automáticas de Windows.
    - Permite configurar un máximo de 18 horas al día en las que el sistema **no se reiniciará** por actualizaciones.
    - Hay opciones avanzada que permiten desactivar las actualizaciones automáticas por un tiempo limitado.
    - Puede deshabilitarse permanentemente, aunque no es recomendable ya que las actualizaciones de seguridad son vitales.
- **Windows Defender:** centro de seguridad integrado de Windows.
    - Incluye un **antivirus**, **antispyware** y el **firewall** de Windows.
    - Si se instala otro antivirus, se debe **desactivar** el de Defender para evitar conflictos.
- **Copias de seguridad:** herramienta para crear copias de seguridad de carpetas y de la instalación de Windows.
- **Recuperación (Restablecer Windows):** permite reinstalar Windows sin necesidad de un CD o ISO. Ofrece dos opciones:
    - **Mantener mis archivos:** se elimina *software* y se restablece Windows, pero se **conservan los archivos** del usuario.
    - **Quitar todo:** restablece Windows a su estado inicial. Se puede elegir entre eliminar solo la unidad donde está Windows o **todas las unidades** (borrando todas las particiones). 

---

*Fin de la 1ª Evaluación*

---