---
id: sistemas-informaticos
sidebar_position: 0
title: Sistemas Informáticos
toc_max_heading_level: 3
---

## UD1.- Software de un sistema informático

### 1.- Sistemas informáticos. Introducción.

Los **sistemas informáticos** realizan tareas de **almacenamiento**, **elaboración** y **presentación** de datos.

Sistema informático: una o más computadoras, el software asociado, los periféricos, los terminales, los operadores humanos, los procesos físicos, los medios de transmisión de la información, etc., que constituyen un todo autónomo capaz de realizar un tratamiento de la información. 

Un sistema informático se compone de:

- Elementos físicos o hardware. 
- Elementos lógicos o software.
- El usuario humano.

### 2.- Software de un sistema informático
#### 2.1.- Requisitos e instalación

El **software** está formado por **programas**, **estructura de datos** y **documentación**.

Para la instalación de un software, debemos seguir los siguientes pasos:

1. Determinación del equipo necesario.
2. Ejecución del programa de instalación.
3. Configuración de la aplicación.

**Determinación del equipo necesario**

Una aplicación creada para una plataforma no podrá ser instalada en otra distinta, ni tampoco si nuestro sistema informático no cumple los requisitos mínimos. 

**Niveles de requisitos para la implantación de aplicaciones**

**1. Equipo básico**
- Plataforma hardware.
- Tipo de microprocesador.
- RAM mínima necesaria. 
- Espacio mínimo necesariamente disponible en el soporte de almacenamiento.
- Plataforma software.
- Resolución recomendada del monitor.
- Tarjeta gráfica necesaria.

**2. Equipo opcional**

- Plataforma hardware recomendada.
- Cantidad de memoria adicional recomendada.
- Presencia de coprocesador matemático (para aplicaciones que realicen gran cantidad de cálculos).
- Tipo de impresora.
- Capacidad recomendada para la tarjeta gráfica.

**3. Equipo en red**

Actualmente muchos fabricantes diseñan las aplicaciones para su funcionamiento en red. El fabricante indicará si la aplicación se ha diseñado para trabajar en red, las configuraciones para el servidor y los clientes, así como los sistemas operativos en red bajo los que puede trabajar.
El  fabricante indicará además si existe alguna limitación en cuanto al número máximo de clientes que pueden trabajar con la aplicación. Así, por cada estación en la  que se instale la aplicación habría que adquirir una licencia de uso para los ordenadores cliente.

**Ejecución del programa de instalación**

La mayoría de las aplicaciones presentan dos niveles de instalación en función de los conocimientos del usuario:

- **Instalación básica**. Diseñada para usuarios con pocos conocimientos informáticos. El programa realizará una instalación en función de los elementos que detecte en el equipo y según unos parámetros básicos establecidos por defecto por el fabricante.
- **Instalación personalizada o avanzada**. Permite al usuario incluir o eliminar elementos de la aplicación con el fin de optimizar los recursos sistema informático, instalando sólo aquellos elementos de la aplicación que se van a utilizar. 

**Configuración de la aplicación**

Una vez instalada la aplicación, el usuario debe configurar el entorno de trabajo. Consiste en definir una serie de parámetros que adecuen el funcionamiento de la aplicación, tales como:

- Ajuste y distribución de la pantalla.
- Definición de directorios de trabajo.

#### 2.2.- Tipos de aplicaciones informáticas

El software se suele clasificar en dos tipos:

- **Aplicaciones de propósito general**. Son las que utilizamos casi todos los usuarios de ordenadores (editores y procesadores de texto, hojas de cálculo, comunicación, generador de presentaciones, antivirus, navegadores web, gestores de archivos, calculadoras, visores pdf...).

- **Aplicaciones de propósito específico**. Son las que se utilizan para el desempeño de funciones específicas, científicas, técnicas o de gestión (administración, contabilidad, facturación, gestión de almacén, entornos de desarrollo, administración de bases de datos, diseño gráfico, ingeniería...)

#### 2.3.- Licencias del software

Las **licencias software** sirven para establecer un contrato entre el **autor de una aplicación** y el **usuario**. En el contrato se definen con precisión los derechos y deberes de ambas partes, es decir, los“**actos de explotación legales**.

Desde el punto de vista de licencia, el software puede ser:

**Software propietario o privativo**

La empresa que desarrolla el software lo vende con limites sobre uso, modiﬁcación o redistribución del software. Los tipos de licencias privativas mas utilizadas son:

- **Licencia CLUF**: se compra el producto en un CD o descargado de Internet, limitándonos el uso del producto a un número de ordenadores o número de instalaciones.
- **Licencia OEM**: software preinstalado en un equipo nuevo.
- **Licencia por volumen (corporativas)**: las empresas grandes adquieren un producto para una gran cantidad de ordenadores.

Casos particulares del software propietario:

- **Freeware**: se usa para el software que puede distribuirse libremente pero no modiﬁcarse. Tampoco suelen facilitan el código fuente. 
- **Shareware**: tiene límites de uso o funcionalidades. Se permite su redistribución, pero no su código. El objetivo es probar un software, y si nos gusta comprarlo.

**Software libre. Licencia GNU**

El software libre autoriza:

- Utilizar el programa, para cualquier propósito.
- Estudiar cómo funciona el programa y adaptarlo a tus necesidades, debe proporcionarse las fuentes, directa o indirectamente, pero siempre de forma fácil y asequible.
- Distribuir copias.
- Mejorar el programa y hacer públicas las mejoras a los demás.

En el momento que no se cumpla una de las cuatro libertades, el software no es libre.

Un software libre se puede distribuir comercialmente, pues en el concepto "software libre" no se habla nada de "gratuidad".

Un tipo de licencia libre, muy utilizado hoy día es **GNU-GPL**, que trata de proteger al autor. Cualquier modificación se debe distribuir de nuevo con una licencia GNU-GPL y citando la fuente original. Así, se evita que otros autores se apropien de un trabajo libre. 

**Protección jurídica del software. Copyright**

- El hardware está protegidos por patentes, pero el software no, ya que se considera algo intangible.
- En España, el software está protegido por la Ley de Propiedad Intelectual modificada. LPI (Año 2006).
- La Ley de propiedad intelectual, protege los libros, la música y el software.
- En el artículo 101 de la LPI, se dice: “Los derechos sobre los programas de ordenador, así como sus sucesivas versiones y los programas derivados, podrán ser objeto de inscripción en el Registro” de la Propiedad Intelectual.
- El Registro es público. Una vez, que la empresa inscriba su obra en el registro, podrá anteponer en la obra el símbolo del copyright ©, precisando lugar y año de divulgación.

**Copyleft frente a copyright**

- El mundo libre, también ha creado sus propios derechos copyleft.
- Frente al software privativo, que se registra en la Ley de Propiedad Intelectual y se establece el copyright, en el software libre se estable el copyleft.- El objetivo de Copyleft es asegurar las licencias GPL, que son software libre, pero que al distribuirlo o modificarlo, se obliga a difundir quien fué el autor del software.
-  En internet, es muy fácil encontrar manuales de informática con licencia copyleft.
- La letra C normal refleja que hay copyright, y la obra es privada y no se puede copiar.
- La letra C invertida, refleja que hay copyleft y la obra es libre, se puede copiar, reutilizar pero nombrando siempre al autor, y volviendo a difundir la obra modificada de forma libre.

### 3.- Introducción a sistemas operativos

Un **sistema operativo** es un conjunto de programas que se encarga de **gestionar los recursos hardware y software del ordenador**, por lo que actúa como una interfaz entre los programas de aplicación del usuario y el hardware puro.

#### 3.1.- Definición, objetivos, kernel y subsistemas de los sistemas operativos

Objetivos de los sistemas operativos:

- Abstraer al usuario de la complejidad del hardware.
- Permitir que los recursos del ordenador se utilicen de la forma más eficiente posible.
- Permitir la ejecución de programas.
- Acceder a los dispositivos de entrada/salida.
- Proporcionar una estructura y conjunto de operaciones para el sistema de archivos.
- Detectar y dar respuesta ante errores.
- Gestionar las comunicaciones en red y permitir a los usuarios compartir datos.

**El kernel o núcleo**

Para realizar todos estas funciones, existe el kernel o núcleo. Representa sólo una pequeña parte de todo lo que es el sistema operativo, pero es una de las partes que más se utiliza. El núcleo reside por lo general en la memoria principal (RAM).

Resumiendo, el núcleo se encarga de:

- Gestión de procesos.
- Gestión de memoria.
- Gestión de archivos.
- Gestión de entrada y salida.

#### 3.2.- Tipos de sistemas operativos

**Clasificación de los SO según su estructura**

- **Monolíticos**. Es la estructura de los primeros sistemas operativos, consistía en un solo programa desarrollado con rutinas entrelazadas que podían llamarse entre sí. Por lo general, eran sistemas operativos hechos a medida, pero difíciles de mantener.

- **Jerárquicos**. Conforme las necesidades de los usuarios aumentaron, los sistemas operativos fueron creciendo en complejidad y funciones. Esto llevó a que se hiciera necesaria una mayor organización del software del sistema operativo, dividiéndose en partes más pequeñas, diferenciadas por funciones y con una interfaz clara para interoperar con los demás elementos. Ejemplo: MULTICS.

- **Capas**. El sistema operativo se organiza por capas, las capas superiores utilizan las inferiores. De esta forma, cada capa solo se fija en los detalles suyos. Ejemplo: THE.

- **Microkernel**. Los ordenadores son muy rápidos y realizan muchos cálculos. Hay muchos fallos. Para incrementar la tolerancia a fallos, se dividen en pequeños núcleos: operaciones de entrada/salida, gestión de memoria, del sistema de archivos, etc. Ejemplo: MINIX.

- **Cliente-servidor**. Basada en la estructura microkernel. El cliente solicita una petición de un servicio en la red, y el servidor responde.

- **Máquina virtual**. Integra distintos sistemas operativos en una sola máquina. En cada una de ellas, se puede ejecutar un sistema operativo distinto. Ejemplo: VMware y VirtualBox.

**Clasificación de los SO por los servicios que ofrecen**

| Criterio | Tipo |
| :--- | :--- |
| Número de usuarios | * **Monousuario**: solo un usuario utiliza el SO al mismo tiempo. Ejemplo: Ms-Dos. <br /> * **Multiusuario**: pueden trabajar varios usuarios al mismo tiempo, bien en el mismo ordenador, bien desde otro ordenador a través de consolas. Ejemplos: Unix, Windows 10. |
| Número de procesos | * **Monoproceso o monotarea**: solo se puede ejecutar un proceso a la vez en cada núcleo. Ejemplo: MS-DOS. <br /> * **Multiproceso o multitarea**: se pueden ejecutar varios procesos a la vez. Ejemplos: Windows actuales, Unix/Linux, Mac OS. |
| Número de procesadores | * **Monoprocesador**: el SO solo se puede utilizar en ordenadores con 1 procesador. Ejemplo: MS-Dos. <br /> * **Multiprocesador**: el SO se puede utilizar en ordenadores con varios procesadores. Ejemplos: Windows actuales, Unix/Linux. |

**Clasificación de los SO por su forma**

| Criterio | Tipo |
| :--- | :--- |
| En red | Estos sistemas tienen la capacidad de interactuar con los sistemas operativos de otras máquinas a través de la red. Ejemplo: Windows Server, Linux. |
| Distribuidos | Las funciones se distribuyen entre diferentes ordenadores, logrando integrar recursos en una sola máquina virtual que es a la que el usuario accede de forma transparente. En este caso, el usuario no necesita saber la ubicación de los recursos, sino que los referencia por su nombre y los utiliza como si fueran locales a su lugar de trabajo habitual. Ejemplo: MOSIX. |

### 4.- Gestión de procesos

#### 4.1.- Estados de los procesos. Bloque de control de procesos

**Definición de proceso**

Cada vez que se abre un programa informático, se genera un proceso principal. Un programa tiene varias instrucciones, y se ejecuta de forma secuencial, es decir, una instrucción detrás de otra.

Cuando se inicia el programa principal, se inicia el proceso principal que controla el programa hasta que finalice el programa. Para ejecutar cada instrucción se inicia un subproceso, de forma que lo habitual es que un programa tenga varios procesos, también llamados subprocesos o hilos de ejecución.

El proceso se ejecutará y finalizará de forma correcta o por error. Estas ideas nos dejan entrever lo que se llama "estados de los procesos".

**Estados de los procesos**

Los diferentes estados de un proceso son:

- **En ejecución o activo**: es el que se ejecuta. En cada núcleo de un procesador, solo puede haber un proceso activo.

- **Preparado o espera** : está preparado para su ejecución, pero a la espera de un procesador libre (hay otro proceso en ejecución).

- **Bloqueado o suspendido**: no puede ejecutarse, porque necesita un recurso que está ocupado. Por ejemplo: si hay 2 impresiones, la segunda está bloqueada, hasta que la primera acabe.

- **Muerto**: su ejecución ha terminado o el sistema operativo ha detectado un error fatal y lo ha transferido a dicho estado. Si se apaga el equipo por falta de alimentación eléctrica, todos los procesos pasan a muertos.

**Transición entre estados de los procesos**

El **planificador de procesos** se encarga de pasar los procesos de unos estados a otros. 

Tiene listas independientes para cada estado, pues se gestiona de forma distinta la lista de procesos preparados de la lista de procesos bloqueados.

Cuando un proceso se crea, y se comprueba si se puede ejecutar, pasa a la lista de procesos preparados, y cuando lo decida el planificador, pasa a estar en ejecución (activo).

Una vez en ejecución, puede pasar a cualquiera de los otros estados:

- De **ejecución** puede pasar a **preparado** porque el planificador decida ejecutar otro proceso.
- De **ejecución** puede pasar a **bloqueado** porque necesita algún dato o está en conflicto con otro proceso.
- De **bloqueado** puede pasar a **preparado** cuando se ha resuelto el problema. 
- Desde **todos los estados**, el proceso puede pasar a **muerto**, tanto porque el proceso finalice como debido a errores del sistema operativo o bloqueo infinito.

**Bloque de control de procesos**

El sistema mantiene toda la información sobre un proceso en una tabla llamada **bloque de control de procesos**. Para cada proceso contiene:

1. Identificador único de proceso (*pid*).
2. Estado del proceso.
3. Prioridad.
4. Dirección de la memoria donde está guardada la información relativa al proceso.
5. Información contable, necesaria para que el planificador realice su trabajo (hora de inicio del proceso, tiempo de espera, tiempo de ejecución que resta, etc.).

#### 4.2.- Planificador de procesos. Algoritmos.

Si la multitarea real no existe, ¿por qué es multitarea y lo parece?

Un PC a 3GHz realiza 3 mil millones de operaciones elementales en 1 segundo. Durante ese segundo, el ordenador cambia muchísimas veces de tarea, de forma que parece que se ejecuta todo a la vez.

**Algoritmos de planificación de procesos**

El planificador de procesos del sistema operativo decide qué proceso de la cola de preparados pasa a estar en ejecución en cada momento. Después, puede decidir dejar el tiempo que necesite el proceso, o que ese proceso pase a preparado, pasando otro de la cola de listos a en ejecución. Estas transiciones continuas, entre procesos listos y en ejecución, es lo que da lugar a la multiprogramación, pues aunque se ejecuta un solo proceso en cada núcleo, da la sensación de que se ejecutan varios procesos a la vez o en paralelo.

Los **algoritmos de planificación de procesos** determinan qué proceso pasa a estar activo. Los algoritmos SRT, Round Robin y Prioridades son los más utilizados en sistemas operativos modernos.

| Algoritmo | Descripción |
| --------- | ----------- |
|   FIFO    | Primero en llegar, primero en salir (First Input, First Output). Es el más sencillo, los procesos pasan a activo en el orden que llegaron a preparado. Una vez que el trabajo se inicia, se ejecuta hasta el final. |
|   SJF     | Primero el trabajo más corto (Shortest Job First). De los procesos que están preparados, se selecciona el que tiene menor tiempo de ejecución. Una vez que el trabajo se inicia, se ejecuta hasta el final. |
|   SRT     | Tiempo restante más corto (Shortest Remaining Time). El planificador utiliza el criterio SJF, pero tiene en cuenta los nuevos procesos que puedan llegar al estado preparado. Por ejemplo, si se está ejecutando un proceso A que le quedan 3 instantes, pero llega un nuevo proceso B al estado preparado que solo necesita 1 instante, el proceso A pasa al estado preparado, mientras que B pasa a ejecución por necesitar menos tiempo. Es el primer algoritmo que utiliza la multiprogramación (un proceso activo se deja de ejecutar para que se ejecute otro). Son algoritmos expropiativos (se quita el procesador al proceso activo). |
|   RR (Round Robin)  | Reparte el tiempo del procesador de forma justa y por turnos. Funciona dando a cada proceso una pequeña porción de tiempo, llamada cuanto. Si el proceso no termina en ese tiempo, la CPU lo detiene momentáneamente y lo envía al final de la fila para que espere su próximo turno, pasando inmediatamente al siguiente proceso en la cola. Este ciclo se repite constantemente, asegurando que todos los procesos reciban atención regularmente, lo que se traduce en un tiempo de respuesta rápido y equitativo para el usuario. |
|   Prioridades  | Cada proceso tiene asignada una prioridad y el de mayor prioridad en el estado listo es el que pasa a estar en ejecución. El valor de prioridad puede ser asignado por el usuario o el sistema. Asimismo, el usuario puede cambiar en cualquier momento la prioridad de un proceso. Las prioridades son buenas, pero por si solas tienen el problema de que un proceso con poca prioridad no se ejecutaría nunca. Para solucionar este problema, se mejora el algoritmo utilizando prioridad por envejecimiento (si un proceso lleva mucho tiempo en estado preparado, se sube su prioridad para tener más posibilidades de pasar a activo). |

Observaciones:

- FIFO puede bloquear procesos muy cortos, por estar ejecutando uno muy largo.
- SJF y SRT pueden bloquear procesos muy largos, por ejecutarse siempre los más cortos.
- FIFO y SJF dan malos resultados, pero son muy fáciles de implantar. El sistema operativo realiza pocos cálculos, por lo que no se pierde tiempo. Son los únicos algoritmos monoproceso, monotarea, no multiprogramados o no expropiativos.
- SRT se utiliza bastante en los sistemas operativos actuales, pues se ha comprobado que da un tiempo medio de espera muy bueno.
- Los algoritmos SRT, Round Robin y prioridades dan buenos resultados. Aun así, lo habitual es utilizar varios algoritmos mezclados. De esa forma, se intenta obtener lo mejor de cada uno.
- En sistemas actuales, se suelen utilizar “prioridad con SRT” y “prioridad con Round Robin”. FIFO y SJF, se utilizan como criterios de desempate final.

### 5.- Gestión de memoria

Hemos visto en la gestión de procesos que el recurso compartido es el procesador. Sin embargo, para que un proceso se pueda ejecutar no sólo requiere tiempo de procesamiento sino también estar cargado en memoria principal. Esto es así, porque ningún proceso se puede activar antes de que se le asigne el espacio de memoria que requiere. Así, la memoria se convierte en otro recurso clave que tendrá que gestionar el sistema operativo y la parte encargada de ello se denomina **gestor de memoria**.

#### 5.1.- Particiones fijas, variables y paginación

- Memoria, memoria principal o memoria física: RAM.

- Memoria secundaria: disco duro.

Actualmente la mayoría de los sistemas operativos son sistemas multitarea, en los que va a haber varios procesos simultáneamente en ejecución. Por tanto, deberá haber mecanismos de gestión para distribuir la memoria principal entre todos estos procesos que quieren ejecutarse.

Los primeros algoritmos para este cometido tienen una gestión fácil pero desperdician mucha memoria. Los algoritmos actuales tienen una gestión más complicada a cambio de ser más eficientes.

**Primer Sistema: Gestión de la memoria con particiones fijas**

Consiste en dividir la memoria física disponible en varias particiones de tamaño fijo y asignar cada una de las partes a un proceso.

Ejemplo: Supongamos un equipo antiguo con MS-DOS y una memoria RAM de 4 Mb, los primeros 512 Kb estaban reservados para los programas de MS-Dos. Los 3,5 MB restantes, es donde se cargaban los programas de usuario (procesador de texto, hoja de cálculo,...), se dividen en 3 particiones de distinto tamaño, por ejemplo, 512 KB, 1 MB y 2 MB. Cada tarea o proceso se asigna a una partición. En cada partición, solo puede haber 1 proceso.

En este sistema, se desaprovecha espacio dentro de cada partición. Se produce fragmentación interna (se desperdicia espacio en la memoria, que no puede utilizar otro proceso).

**Segundo sistema: Gestión de la memoria con particiones variables**

No hay particiones, a cada proceso se le asigna el tamaño que hace falta. Cuando termina el proceso se libera ese trozo, y se junta con el espacio libre que haya al lado.

Cada proceso nuevo se carga donde haya espacio, y lo que no se utilice queda libre para otro proceso.

En este sistema, no se pierde espacio dentro de las particiones, pero si pueden desperdiciarse huecos libres que van quedando, pero que no se pueden aprovechar porque son pequeños. Se produce fragmentación externa (se desperdicia espacio en la memoria, pero de forma general, no dentro de una partición)

**Tercer sistema: Paginación**

La memoria se divide en páginas de igual tamaño. Los procesos utilizan las páginas necesarias, no siendo obligatorio que sean contiguas (continuas).

Ejemplo, el tamaño de las páginas suele ser 4KB, si el proceso necesita 31 KB, utilizará 8 páginas libres, independientemente si están juntas o no.

Es más difícil de gestionar y se necesitan computadoras más potentes, pero se aprovecha muy bien la memoria. La fragmentación es casi cero.

Poco a poco, las páginas libres quedan muy desorganizadas. El sistema operativo puede perder tiempo en asignar muchas páginas no contiguas a los procesos, por lo que cada poco tiempo realiza una compactación. Esto consiste en organizar todas las páginas, de forma que tanto las páginas libres como las de los procesos estén juntas.

Por este motivo, la **paginación** es la técnica que se utiliza en la **actualidad**.

#### 5.2.- Memoria virtual (Windows) y memoria swap (Linux)

**Memoria virtual en Windows**

La memoria RAM es cara y limitada. Debido a esto nació este sistema, que consiste en sobrepasar el límite de memoria RAM, guardando la información en el disco duro como si fuera RAM.

La memoria virtual suele tener entre 1 y 2 veces el tamaño de la RAM.

Cada vez que se carga un proceso en la memoria RAM, también se escribe en la memoria virtual. Cuando la RAM se está llenando, se puede borrar las que sobran e introducir las nuevas. Si hacen falta las antiguas, se provocará un fallo de página, y el gestor de memoria traerá dicha parte del proceso de disco a memoria.

De esta forma, aunque la memoria virtual es más lenta que la RAM, si tenemos una RAM de 2 GB, podríamos simular una RAM de 6 GB con la ayuda de la memoria virtual en disco duro.

El archivo `pagefile.sys` oculto en la partición donde está instalado Windows es el archivo de la memoria virtual, también llamado archivo de paginación (pues también utiliza paginación dentro del archivo). Aun así, no hay que confundir la memoria virtual con la paginación a secas.

**Memoria swap o área de intercambio en GNU-Linux**

El concepto es el mismo que memoria virtual. La diferencia es que, en Linux, al instalar el sistema operativo, se crea una partición expresa para este fin. Lo habitual es utilizar entre 1 y 2 veces el tamaño de la RAM.

Ventajas de memoria swap sobre memoria virtual:

- No depende de que la partición de datos esté muy llena.
- Si se pone la swap en la primera partición del disco duro, gana en velocidad, pues esa zona del disco duro es más rápida.

En Linux se utiliza el comando `free` para ver cuanta memoria principal y cuánta swap tiene el equipo y su consumo.

Tendencia actual en la memoria swap o memoria virtual:

Actualmente, los ordenadores tienen memoria RAM muy grande, por lo que se discute si es necesario poner memoria virtual o swap o no configurarla.

En cualquier caso, en un ordenador con RAM muy grande se suele poner como tamaño de la virtual o swap la misma cantidad que tiene de RAM. Si la cantidad de RAM es justa, pondremos el doble. Una razón para seguirla poniendo en Linux, es que la partición swap se utiliza también cuando se hiberna el sistema.

### 6.- Gestión de entrada y salida

Una de las funciones del ordenador es procesar la información, que es obtenida y mostrada a través de los periféricos. La parte del sistema operativo que se encarga de este proceso es la **gestión de la E/S (entrada/salida)**.

#### 6.1.- Estructura y transferencia de datos

**Controladores de dispositivo**

Hay multitud de tipos y fabricantes de periféricos, esto conlleva que tanto el sistema operativo como los fabricantes de periféricos deben estandarizar el acceso a los dispositivos utilizando los controladores de dispositivos.

**Controlador o Driver**: software suministrado por el fabricante del dispositivo o el desarrollador del sistema operativo que actúa como interfaz entre los programas y el hardware.

**Estructura de datos de la E/S**

Se refiere a la estructura de datos que utilizan los dispositivos periféricos para manejar la información y comunicación entre dispositivos o entre estos y la CPU. Las más utilizadas son:

- **Spool**. Los datos de salida se almacenan de forma temporal en una cola situada en un dispositivo de almacenamiento masivo (*spool*), hasta que el periférico requerido se encuentre libre. De este modo se evita que un programa quede retenido porque el periférico no esté disponible. El sistema operativo dispone de llamadas para añadir y eliminar archivos del spool. Se utiliza en dispositivos que no admiten intercalación, como ocurre en la impresora, ya que no puede empezar una impresión hasta que no haya terminado la anterior.

- **Buffers**. Es para dispositivos que pueden atender peticiones de distintos orígenes. Los datos no tienen que enviarse completos, pueden enviarse porciones que el buffer retiene de forma temporal. También se utilizan para acoplar velocidades de distintos dispositivos. Así, si un dispositivo lento va a recibir información más rápido de lo que puede atenderla se emplea un buffer para retener temporalmente la información hasta que el dispositivo pueda asimilarla. Esto ocurre entre una grabadora de DVD y el disco duro, ya que la primera funciona a una menor velocidad que el segundo.

**Transferencia de los datos de la E/S**

Existen distintas formas de transferir los datos de E/S en los sistemas operativos según la intervención de la CPU. Son las siguientes, ordenadas de menos eficientes a más eficientes:

- **E/S programada**. La CPU tiene todo el protagonismo ya que inicia y lleva a cabo la transferencia. Esta técnica repercute en la velocidad de proceso del ordenador, porque la CPU debe dejar todo lo que está haciendo para ocuparse del proceso de entrada/salida.

- **E/S por interrupciones**. La CPU ejecuta la transferencia pero el inicio es pedido por el periférico que indica así su disponibilidad. La CPU no pregunta a los dispositivos sino que son estos los que la avisan cuando es necesario.

- **Acceso directo a memoria (DMA)**. La transferencia es realizada por un controlador especializado. Esta técnica acelera enormemente el proceso de la E/S y libera a la CPU de trabajo. Lo habitual es que los datos que se quieren escribir en el dispositivo o que son leídos del dispositivo provengan o vayan a la memoria del ordenador, pues bien en este caso. la CPU inicia el proceso, pero luego el dispositivo continúa sin necesitar a la CPU, con lo que se acelera mucho el proceso de entrada/salida y se libera a la CPU del proceso.

### 7.- Gestión de archivos
#### 7.1.- Organización lógica: directorios y ficheros

Cada sistema operativo utilizará su propio sistema de archivos, no obstante las operaciones que se pueden realizar sobre el sistema de archivos son bastante similares. Así, todos los sistemas de archivos actuales utilizan los directorios o carpetas para organizar a los archivos.

**Objetivos en la implementación de un sistema de archivos**

- Optimizar el rendimiento mediante un acceso rápido cuando se recupera información.
- Fácil actualización de los archivos.
- Intentar que los archivos desperdicien la menor cantidad de espacio en disco posible.
- Mantenimiento sencillo.
- Fiabilidad para asegurar que los datos sean correctos y fiables.
- Incorporar mecanismos de seguridad y permisos.
- Control de concurrencia.

**Organización lógica del sistema de archivos**

Los sistemas de archivos deben permitir utilizar el medio de almacenamiento (disco) de una forma intuitiva y cómoda, sin conocer los detalles de hardware.

A esto se le llama organización del sistema de archivos y suele coincidir en todos los sistemas de archivos actuales, utilizando el esquema de almacenamiento en archivos y la organización en carpetas o directorios.

Un directorio o carpeta solo es un contenedor, no contiene información, ésta se encuentra en los archivos.

Cada archivo de un sistema tendrá unos atributos que lo identifican:

1. Nombre
2. Extensión
3. Permisos
4. Propietario
5. Fecha de creación
6. Fecha del último acceso
7. Fecha de la última modificación
8. Tamaño actual

**Jerarquía de directorios. Árboles**

Todos los sistemas operativos tienen una estructura jerárquica de almacenamiento de la información en forma de árbol.

### 8.- Virtualización. Software y configuración de máquinas virtuales.

#### 8.1.- Motivación y ventajas de las máquinas virtuales.

Gracias a la virtualización o máquinas virtuales, en un ordenador puede haber varias máquinas distintas ejecutándose.

Las máquinas virtuales se pueden comunicar en una red, siendo vistas como computadores distintas.

Una máquina virtual, se instala y ejecuta bajo un software, de forma que es una carpeta con algunos archivos. El disco duro es un archivo, y el resto de archivos son la configuración de la máquina. De esta forma, resulta muy fácil el traslado de una máquina virtual de un ordenador a otro ordenador.

Términos:

- **Máquina anfitrión, host o servidor:** máquina real donde se instala la aplicación de virtualización.
- **Máquina invitada, huésped o guest**: máquina virtual que se ejecuta dentro de la aplicación.

**Software de virtualización**

Software de varias empresas: Vmware, Oracle, Microsoft, Parallels

- **Vmware**. Software propietario. Tiene muchas versiones, algunas de pago y otras gratuitas (Server, Workstation y Player).

- **VirtualBox**. Software original de Sun Microsystems, comprada posteriormente por Oracle. Tiene dos versiones principales (VirtualBox y VirtualBox OSE).

- **HiperV**. Software propietario de Microsoft para ordenadores con Windows. Tiene dos programas (Virtual PC e Hiper V).

- **Parallels**. Software propietario para ordenadores MAC. Se puede virtualizar tanto Windows como Linux.

#### 8.2.- Instalación y configuración de una máquina virtual nueva

Para crear una máquina, se indican los siguientes parámetros:

1. Nombre.
2. Sistema operativo que se va a instalar.
3. Memoria RAM.
4. Disco duro.

**Diferencia de tamaño fijo y tamaño dinámico al crear un disco duro**

Al crear un disco duro, se puede crear de tamaño dinámico (el archivo crece según metemos información en la máquina virtual) o tamaño fijo (el archivo ocupa siempre el tamaño total del disco duro). 

**Configuración de la máquina virtual**

Una vez creada una máquina virtual, se puede:

- Añadir o eliminar medios de almacenamiento.
- Habilitar los puertos USB de la máquina host.
- Configurar la red (NAT, puente, red interna).
- Compartir carpetas entre la máquina host y la invitada.

**Herramientas de optimización**

Para que las máquinas funcionen con mejores características, hay que instalar las herramientas que adaptan el hardware de la máquina real a la invitada (es decir, instalan u optimizan los drivers). Cada programa tiene su propia herramienta para este fin.

Ventajas de instalar estas herramientas:

- Mejor resolución gráfica.
- Integración del ratón.
- Acceso a carpetas compartidas.
- Compartir el portapapeles.

#### 8.3.- Configuración de VirtualBox

**Instantáneas o snapshots**

Si vamos a instalar algún programa, o queremos hacer pruebas al sistema, y pensamos que pueden fallar esas pruebas, podemos realizar instantáneas al sistema. De esa forma, una vez acabada las nuevas instalaciones o pruebas, podemos decidir, si nos quedamos con la versión más actualizada del Sistema Operativo (Eliminar instantánea) o la versión antigua (Restaurar instantánea). Cada instantánea va generando archivo .vdi nuevos con las diferencias.

**Extensiones de los discos duros, según programas**

- VirtualBox → vdi
- Vmware → vmdk
- Virtual PC → vhd

Aun así, no hay problema de compatibilidad entre VMware y VirtualBox, pues se pueden exportar e importar las máquinas.

**Trasladar una máquina a otro PC**

1. Disco duro. El disco duro de una máquina virtual, es un único archivo .vdi. Este archivo se puede copiar en cualquier otro ordenador y tener una máquina instalada en un momento. Hay que crear la máquina nueva y en el momento de poner disco duro elegir el disco existente con su ruta.

2. Máquina entera. Para ello se debe exportar el servicio virtualizado, obteniendo un archivo con extensión .ova.
Este archivo servirá para importar la máquina en ese PC o en otro. La diferencia, es que el archivo .ova es toda la máquina.

**Administrador de discos de VirtualBox**

Al igual que un disco duro físico no puede estar en 2 sitios a la vez, no podemos tener duplicado el disco duro en 2 máquinas virtuales, aunque se llamen de forma distinta y tengan cosas distintas.
Cada disco tiene un número de serie y no puede haber 2 archivos .vdi con el mismo número de serie.

**Soluciones**

Hay varias soluciones para copiar un disco sin provocar errores por UUID:

1. Copiar el disco (crea una copia con UUID distinto).
2. Clonar la máquina (no solo copia el disco, sino que crea otra máquina con sus archivos de configuración).
3. Exportar el servicio virtualizado (se genera el archivo .ova).

**Configuración de red en VirtualBox**

La máquina virtual tiene una tarjeta de red virtual (se pueden poner varias tarjetas de red virtuales).
Esta tarjeta de red virtual se conecta con la máquina anfitrión según la configuración que se seleccione. Las configuraciones posibles son:

- **No conectado** -> La máquina invitada no tiene red.
- **NAT: Network Address Translation** -> Modo más simple, pues sin ninguna configuración adicional la máquina virtual navega por Internet. La máquina virtual no se puede conectar ni con la anfitrión ni con otras máquinas virtuales y, por tanto, no puede compartir archivos. La dirección IP en la máquina invitada la asigna dinámicamente Virtualbox. Este modo es perfecto para realizar todo tipo de pruebas, ya que la red no puede infectar a la máquina y al contrario.
- **Bridged / Adaptador Puente** -> Se forma un puente entre la tarjeta virtual de la máquina invitada y la tarjeta real de la máquina anfitrión. Es como si fueran la misma tarjeta. A todos los efectos la máquina invitada es como si estuviera conectada a la red como una máquina real.
- **Red Interna** -> Crear una red interna visible entre las máquinas invitadas, pero no con la anfitrión ni con la red general. Se utiliza cuando queremos tener una red entre las máquinas virtuales.
- **Host-only networking / Adaptador sólo-anfitrión** -> En este modo cada máquina invitada solo puede comunicarse con la máquina anfitrión, sin que se puedan comunicar entre las invitadas. El direccionamiento de las mismas es dinámico y lo asigna VirtualBox.