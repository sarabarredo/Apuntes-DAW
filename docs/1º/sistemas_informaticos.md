---
id: sistemas-informaticos
sidebar_position: 0
title: Sistemas Informáticos
toc_max_heading_level: 3
---

## UD1.- Software de un sistema informático

![Esquema Unidad 1 Sistemas Informáticos](../../static/img/sistemas-informaticos-unidad-1.jpg)

### 1.- Sistemas informáticos. Introducción.

Los **sistemas informáticos** realizan tareas de **almacenamiento**, **elaboración** y **presentación** de datos.

Sistema informático: una o más computadoras, el software asociado, los periféricos, los terminales, los operadores humanos, los procesos físicos, los medios de transmisión de la información, etc., que constituyen un todo autónomo capaz de realizar un tratamiento de la información. 

Un sistema informático se compone de:

- Elementos físicos o hardware. 
- Elementos lógicos o software.
- El usuario humano.

### 2.- Software de un sistema informático
#### 2.1.- Requisitos e instalación

El **software** está formado por **programas**, **estructura de datos** y **documentación**.

Para la instalación de un software, debemos seguir los siguientes pasos:

1. Determinación del equipo necesario.
2. Ejecución del programa de instalación.
3. Configuración de la aplicación.

**Determinación del equipo necesario**

Una aplicación creada para una plataforma no podrá ser instalada en otra distinta, ni tampoco si nuestro sistema informático no cumple los requisitos mínimos. 

**Niveles de requisitos para la implantación de aplicaciones**

**1. Equipo básico**
- Plataforma hardware.
- Tipo de microprocesador.
- RAM mínima necesaria. 
- Espacio mínimo necesariamente disponible en el soporte de almacenamiento.
- Plataforma software.
- Resolución recomendada del monitor.
- Tarjeta gráfica necesaria.

**2. Equipo opcional**

- Plataforma hardware recomendada.
- Cantidad de memoria adicional recomendada.
- Presencia de coprocesador matemático (para aplicaciones que realicen gran cantidad de cálculos).
- Tipo de impresora.
- Capacidad recomendada para la tarjeta gráfica.

**3. Equipo en red**

Actualmente muchos fabricantes diseñan las aplicaciones para su funcionamiento en red. El fabricante indicará si la aplicación se ha diseñado para trabajar en red, las configuraciones para el servidor y los clientes, así como los sistemas operativos en red bajo los que puede trabajar.
El  fabricante indicará además si existe alguna limitación en cuanto al número máximo de clientes que pueden trabajar con la aplicación. Así, por cada estación en la  que se instale la aplicación habría que adquirir una licencia de uso para los ordenadores cliente.

**Ejecución del programa de instalación**

La mayoría de las aplicaciones presentan dos niveles de instalación en función de los conocimientos del usuario:

- **Instalación básica**. Diseñada para usuarios con pocos conocimientos informáticos. El programa realizará una instalación en función de los elementos que detecte en el equipo y según unos parámetros básicos establecidos por defecto por el fabricante.
- **Instalación personalizada o avanzada**. Permite al usuario incluir o eliminar elementos de la aplicación con el fin de optimizar los recursos sistema informático, instalando sólo aquellos elementos de la aplicación que se van a utilizar. 

**Configuración de la aplicación**

Una vez instalada la aplicación, el usuario debe configurar el entorno de trabajo. Consiste en definir una serie de parámetros que adecuen el funcionamiento de la aplicación, tales como:

- Ajuste y distribución de la pantalla.
- Definición de directorios de trabajo.

#### 2.2.- Tipos de aplicaciones informáticas

El software se suele clasificar en dos tipos:

- **Aplicaciones de propósito general**. Son las que utilizamos casi todos los usuarios de ordenadores (editores y procesadores de texto, hojas de cálculo, comunicación, generador de presentaciones, antivirus, navegadores web, gestores de archivos, calculadoras, visores pdf...).

- **Aplicaciones de propósito específico**. Son las que se utilizan para el desempeño de funciones específicas, científicas, técnicas o de gestión (administración, contabilidad, facturación, gestión de almacén, entornos de desarrollo, administración de bases de datos, diseño gráfico, ingeniería...)

#### 2.3.- Licencias del software

Las **licencias software** sirven para establecer un contrato entre el **autor de una aplicación** y el **usuario**. En el contrato se definen con precisión los derechos y deberes de ambas partes, es decir, los“**actos de explotación legales**.

Desde el punto de vista de licencia, el software puede ser:

**Software propietario o privativo**

La empresa que desarrolla el software lo vende con limites sobre uso, modiﬁcación o redistribución del software. Los tipos de licencias privativas mas utilizadas son:

- **Licencia CLUF**: se compra el producto en un CD o descargado de Internet, limitándonos el uso del producto a un número de ordenadores o número de instalaciones.
- **Licencia OEM**: software preinstalado en un equipo nuevo.
- **Licencia por volumen (corporativas)**: las empresas grandes adquieren un producto para una gran cantidad de ordenadores.

Casos particulares del software propietario:

- **Freeware**: se usa para el software que puede distribuirse libremente pero no modiﬁcarse. Tampoco suelen facilitan el código fuente. 
- **Shareware**: tiene límites de uso o funcionalidades. Se permite su redistribución, pero no su código. El objetivo es probar un software, y si nos gusta comprarlo.

**Software libre. Licencia GNU**

El software libre autoriza:

- Utilizar el programa, para cualquier propósito.
- Estudiar cómo funciona el programa y adaptarlo a tus necesidades, debe proporcionarse las fuentes, directa o indirectamente, pero siempre de forma fácil y asequible.
- Distribuir copias.
- Mejorar el programa y hacer públicas las mejoras a los demás.

En el momento que no se cumpla una de las cuatro libertades, el software no es libre.

Un software libre se puede distribuir comercialmente, pues en el concepto "software libre" no se habla nada de "gratuidad".

Un tipo de licencia libre, muy utilizado hoy día es **GNU-GPL**, que trata de proteger al autor. Cualquier modificación se debe distribuir de nuevo con una licencia GNU-GPL y citando la fuente original. Así, se evita que otros autores se apropien de un trabajo libre. 

**Protección jurídica del software. Copyright**

- El hardware está protegidos por patentes, pero el software no, ya que se considera algo intangible.
- En España, el software está protegido por la Ley de Propiedad Intelectual modificada. LPI (Año 2006).
- La Ley de propiedad intelectual, protege los libros, la música y el software.
- En el artículo 101 de la LPI, se dice: “Los derechos sobre los programas de ordenador, así como sus sucesivas versiones y los programas derivados, podrán ser objeto de inscripción en el Registro” de la Propiedad Intelectual.
- El Registro es público. Una vez, que la empresa inscriba su obra en el registro, podrá anteponer en la obra el símbolo del copyright ©, precisando lugar y año de divulgación.

**Copyleft frente a copyright**

- El mundo libre, también ha creado sus propios derechos copyleft.
- Frente al software privativo, que se registra en la Ley de Propiedad Intelectual y se establece el copyright, en el software libre se estable el copyleft.- El objetivo de Copyleft es asegurar las licencias GPL, que son software libre, pero que al distribuirlo o modificarlo, se obliga a difundir quien fué el autor del software.
-  En internet, es muy fácil encontrar manuales de informática con licencia copyleft.
- La letra C normal refleja que hay copyright, y la obra es privada y no se puede copiar.
- La letra C invertida, refleja que hay copyleft y la obra es libre, se puede copiar, reutilizar pero nombrando siempre al autor, y volviendo a difundir la obra modificada de forma libre.

### 3.- Introducción a sistemas operativos

Un **sistema operativo** es un conjunto de programas que se encarga de **gestionar los recursos hardware y software del ordenador**, por lo que actúa como una interfaz entre los programas de aplicación del usuario y el hardware puro.

#### 3.1.- Definición, objetivos, kernel y subsistemas de los sistemas operativos

Objetivos de los sistemas operativos:

- Abstraer al usuario de la complejidad del hardware.
- Permitir que los recursos del ordenador se utilicen de la forma más eficiente posible.
- Permitir la ejecución de programas.
- Acceder a los dispositivos de entrada/salida.
- Proporcionar una estructura y conjunto de operaciones para el sistema de archivos.
- Detectar y dar respuesta ante errores.
- Gestionar las comunicaciones en red y permitir a los usuarios compartir datos.

**El kernel o núcleo**

Para realizar todos estas funciones, existe el kernel o núcleo. Representa sólo una pequeña parte de todo lo que es el sistema operativo, pero es una de las partes que más se utiliza. El núcleo reside por lo general en la memoria principal (RAM).

Resumiendo, el núcleo se encarga de:

- Gestión de procesos.
- Gestión de memoria.
- Gestión de archivos.
- Gestión de entrada y salida.

#### 3.2.- Tipos de sistemas operativos

**Clasificación de los SO según su estructura**

- **Monolíticos**. Es la estructura de los primeros sistemas operativos, consistía en un solo programa desarrollado con rutinas entrelazadas que podían llamarse entre sí. Por lo general, eran sistemas operativos hechos a medida, pero difíciles de mantener.

- **Jerárquicos**. Conforme las necesidades de los usuarios aumentaron, los sistemas operativos fueron creciendo en complejidad y funciones. Esto llevó a que se hiciera necesaria una mayor organización del software del sistema operativo, dividiéndose en partes más pequeñas, diferenciadas por funciones y con una interfaz clara para interoperar con los demás elementos. Ejemplo: MULTICS.

- **Capas**. El sistema operativo se organiza por capas, las capas superiores utilizan las inferiores. De esta forma, cada capa solo se fija en los detalles suyos. Ejemplo: THE.

- **Microkernel**. Los ordenadores son muy rápidos y realizan muchos cálculos. Hay muchos fallos. Para incrementar la tolerancia a fallos, se dividen en pequeños núcleos: operaciones de entrada/salida, gestión de memoria, del sistema de archivos, etc. Ejemplo: MINIX.

- **Cliente-servidor**. Basada en la estructura microkernel. El cliente solicita una petición de un servicio en la red, y el servidor responde.

- **Máquina virtual**. Integra distintos sistemas operativos en una sola máquina. En cada una de ellas, se puede ejecutar un sistema operativo distinto. Ejemplo: VMware y VirtualBox.

**Clasificación de los SO por los servicios que ofrecen**

| Criterio | Tipo |
| :--- | :--- |
| Número de usuarios | * **Monousuario**: solo un usuario utiliza el SO al mismo tiempo. Ejemplo: Ms-Dos. <br /> * **Multiusuario**: pueden trabajar varios usuarios al mismo tiempo, bien en el mismo ordenador, bien desde otro ordenador a través de consolas. Ejemplos: Unix, Windows 10. |
| Número de procesos | * **Monoproceso o monotarea**: solo se puede ejecutar un proceso a la vez en cada núcleo. Ejemplo: MS-DOS. <br /> * **Multiproceso o multitarea**: se pueden ejecutar varios procesos a la vez. Ejemplos: Windows actuales, Unix/Linux, Mac OS. |
| Número de procesadores | * **Monoprocesador**: el SO solo se puede utilizar en ordenadores con 1 procesador. Ejemplo: MS-Dos. <br /> * **Multiprocesador**: el SO se puede utilizar en ordenadores con varios procesadores. Ejemplos: Windows actuales, Unix/Linux. |

**Clasificación de los SO por su forma**

| Criterio | Tipo |
| :--- | :--- |
| En red | Estos sistemas tienen la capacidad de interactuar con los sistemas operativos de otras máquinas a través de la red. Ejemplo: Windows Server, Linux. |
| Distribuidos | Las funciones se distribuyen entre diferentes ordenadores, logrando integrar recursos en una sola máquina virtual que es a la que el usuario accede de forma transparente. En este caso, el usuario no necesita saber la ubicación de los recursos, sino que los referencia por su nombre y los utiliza como si fueran locales a su lugar de trabajo habitual. Ejemplo: MOSIX. |

### 4.- Gestión de procesos

#### 4.1.- Estados de los procesos. Bloque de control de procesos

**Definición de proceso**

Cada vez que se abre un programa informático, se genera un proceso principal. Un programa tiene varias instrucciones, y se ejecuta de forma secuencial, es decir, una instrucción detrás de otra.

Cuando se inicia el programa principal, se inicia el proceso principal que controla el programa hasta que finalice el programa. Para ejecutar cada instrucción se inicia un subproceso, de forma que lo habitual es que un programa tenga varios procesos, también llamados subprocesos o hilos de ejecución.

El proceso se ejecutará y finalizará de forma correcta o por error. Estas ideas nos dejan entrever lo que se llama "estados de los procesos".

**Estados de los procesos**

Los diferentes estados de un proceso son:

- **En ejecución o activo**: es el que se ejecuta. En cada núcleo de un procesador, solo puede haber un proceso activo.

- **Preparado o espera** : está preparado para su ejecución, pero a la espera de un procesador libre (hay otro proceso en ejecución).

- **Bloqueado o suspendido**: no puede ejecutarse, porque necesita un recurso que está ocupado. Por ejemplo: si hay 2 impresiones, la segunda está bloqueada, hasta que la primera acabe.

- **Muerto**: su ejecución ha terminado o el sistema operativo ha detectado un error fatal y lo ha transferido a dicho estado. Si se apaga el equipo por falta de alimentación eléctrica, todos los procesos pasan a muertos.

**Transición entre estados de los procesos**

El **planificador de procesos** se encarga de pasar los procesos de unos estados a otros. 

Tiene listas independientes para cada estado, pues se gestiona de forma distinta la lista de procesos preparados de la lista de procesos bloqueados.

Cuando un proceso se crea, y se comprueba si se puede ejecutar, pasa a la lista de procesos preparados, y cuando lo decida el planificador, pasa a estar en ejecución (activo).

Una vez en ejecución, puede pasar a cualquiera de los otros estados:

- De **ejecución** puede pasar a **preparado** porque el planificador decida ejecutar otro proceso.
- De **ejecución** puede pasar a **bloqueado** porque necesita algún dato o está en conflicto con otro proceso.
- De **bloqueado** puede pasar a **preparado** cuando se ha resuelto el problema. 
- Desde **todos los estados**, el proceso puede pasar a **muerto**, tanto porque el proceso finalice como debido a errores del sistema operativo o bloqueo infinito.

**Bloque de control de procesos**

El sistema mantiene toda la información sobre un proceso en una tabla llamada **bloque de control de procesos**. Para cada proceso contiene:

1. Identificador único de proceso (*pid*).
2. Estado del proceso.
3. Prioridad.
4. Dirección de la memoria donde está guardada la información relativa al proceso.
5. Información contable, necesaria para que el planificador realice su trabajo (hora de inicio del proceso, tiempo de espera, tiempo de ejecución que resta, etc.).

#### 4.2.- Planificador de procesos. Algoritmos.

Si la multitarea real no existe, ¿por qué es multitarea y lo parece?

Un PC a 3GHz realiza 3 mil millones de operaciones elementales en 1 segundo. Durante ese segundo, el ordenador cambia muchísimas veces de tarea, de forma que parece que se ejecuta todo a la vez.

**Algoritmos de planificación de procesos**

El planificador de procesos del sistema operativo decide qué proceso de la cola de preparados pasa a estar en ejecución en cada momento. Después, puede decidir dejar el tiempo que necesite el proceso, o que ese proceso pase a preparado, pasando otro de la cola de listos a en ejecución. Estas transiciones continuas, entre procesos listos y en ejecución, es lo que da lugar a la multiprogramación, pues aunque se ejecuta un solo proceso en cada núcleo, da la sensación de que se ejecutan varios procesos a la vez o en paralelo.

Los **algoritmos de planificación de procesos** determinan qué proceso pasa a estar activo. Los algoritmos SRT, Round Robin y Prioridades son los más utilizados en sistemas operativos modernos.

| Algoritmo | Descripción |
| --------- | ----------- |
|   FIFO    | Primero en llegar, primero en salir (First Input, First Output). Es el más sencillo, los procesos pasan a activo en el orden que llegaron a preparado. Una vez que el trabajo se inicia, se ejecuta hasta el final. |
|   SJF     | Primero el trabajo más corto (Shortest Job First). De los procesos que están preparados, se selecciona el que tiene menor tiempo de ejecución. Una vez que el trabajo se inicia, se ejecuta hasta el final. |
|   SRT     | Tiempo restante más corto (Shortest Remaining Time). El planificador utiliza el criterio SJF, pero tiene en cuenta los nuevos procesos que puedan llegar al estado preparado. Por ejemplo, si se está ejecutando un proceso A que le quedan 3 instantes, pero llega un nuevo proceso B al estado preparado que solo necesita 1 instante, el proceso A pasa al estado preparado, mientras que B pasa a ejecución por necesitar menos tiempo. Es el primer algoritmo que utiliza la multiprogramación (un proceso activo se deja de ejecutar para que se ejecute otro). Son algoritmos expropiativos (se quita el procesador al proceso activo). |
|   RR (Round Robin)  | Reparte el tiempo del procesador de forma justa y por turnos. Funciona dando a cada proceso una pequeña porción de tiempo, llamada cuanto. Si el proceso no termina en ese tiempo, la CPU lo detiene momentáneamente y lo envía al final de la fila para que espere su próximo turno, pasando inmediatamente al siguiente proceso en la cola. Este ciclo se repite constantemente, asegurando que todos los procesos reciban atención regularmente, lo que se traduce en un tiempo de respuesta rápido y equitativo para el usuario. |
|   Prioridades  | Cada proceso tiene asignada una prioridad y el de mayor prioridad en el estado listo es el que pasa a estar en ejecución. El valor de prioridad puede ser asignado por el usuario o el sistema. Asimismo, el usuario puede cambiar en cualquier momento la prioridad de un proceso. Las prioridades son buenas, pero por si solas tienen el problema de que un proceso con poca prioridad no se ejecutaría nunca. Para solucionar este problema, se mejora el algoritmo utilizando prioridad por envejecimiento (si un proceso lleva mucho tiempo en estado preparado, se sube su prioridad para tener más posibilidades de pasar a activo). |

Observaciones:

- FIFO puede bloquear procesos muy cortos, por estar ejecutando uno muy largo.
- SJF y SRT pueden bloquear procesos muy largos, por ejecutarse siempre los más cortos.
- FIFO y SJF dan malos resultados, pero son muy fáciles de implantar. El sistema operativo realiza pocos cálculos, por lo que no se pierde tiempo. Son los únicos algoritmos monoproceso, monotarea, no multiprogramados o no expropiativos.
- SRT se utiliza bastante en los sistemas operativos actuales, pues se ha comprobado que da un tiempo medio de espera muy bueno.
- Los algoritmos SRT, Round Robin y prioridades dan buenos resultados. Aun así, lo habitual es utilizar varios algoritmos mezclados. De esa forma, se intenta obtener lo mejor de cada uno.
- En sistemas actuales, se suelen utilizar “prioridad con SRT” y “prioridad con Round Robin”. FIFO y SJF, se utilizan como criterios de desempate final.

### 5.- Gestión de memoria

Hemos visto en la gestión de procesos que el recurso compartido es el procesador. Sin embargo, para que un proceso se pueda ejecutar no sólo requiere tiempo de procesamiento sino también estar cargado en memoria principal. Esto es así, porque ningún proceso se puede activar antes de que se le asigne el espacio de memoria que requiere. Así, la memoria se convierte en otro recurso clave que tendrá que gestionar el sistema operativo y la parte encargada de ello se denomina **gestor de memoria**.

#### 5.1.- Particiones fijas, variables y paginación

- Memoria, memoria principal o memoria física: RAM.

- Memoria secundaria: disco duro.

Actualmente la mayoría de los sistemas operativos son sistemas multitarea, en los que va a haber varios procesos simultáneamente en ejecución. Por tanto, deberá haber mecanismos de gestión para distribuir la memoria principal entre todos estos procesos que quieren ejecutarse.

Los primeros algoritmos para este cometido tienen una gestión fácil pero desperdician mucha memoria. Los algoritmos actuales tienen una gestión más complicada a cambio de ser más eficientes.

**Primer Sistema: Gestión de la memoria con particiones fijas**

Consiste en dividir la memoria física disponible en varias particiones de tamaño fijo y asignar cada una de las partes a un proceso.

Ejemplo: Supongamos un equipo antiguo con MS-DOS y una memoria RAM de 4 Mb, los primeros 512 Kb estaban reservados para los programas de MS-Dos. Los 3,5 MB restantes, es donde se cargaban los programas de usuario (procesador de texto, hoja de cálculo,...), se dividen en 3 particiones de distinto tamaño, por ejemplo, 512 KB, 1 MB y 2 MB. Cada tarea o proceso se asigna a una partición. En cada partición, solo puede haber 1 proceso.

En este sistema, se desaprovecha espacio dentro de cada partición. Se produce fragmentación interna (se desperdicia espacio en la memoria, que no puede utilizar otro proceso).

**Segundo sistema: Gestión de la memoria con particiones variables**

No hay particiones, a cada proceso se le asigna el tamaño que hace falta. Cuando termina el proceso se libera ese trozo, y se junta con el espacio libre que haya al lado.

Cada proceso nuevo se carga donde haya espacio, y lo que no se utilice queda libre para otro proceso.

En este sistema, no se pierde espacio dentro de las particiones, pero si pueden desperdiciarse huecos libres que van quedando, pero que no se pueden aprovechar porque son pequeños. Se produce fragmentación externa (se desperdicia espacio en la memoria, pero de forma general, no dentro de una partición)

**Tercer sistema: Paginación**

La memoria se divide en páginas de igual tamaño. Los procesos utilizan las páginas necesarias, no siendo obligatorio que sean contiguas (continuas).

Ejemplo, el tamaño de las páginas suele ser 4KB, si el proceso necesita 31 KB, utilizará 8 páginas libres, independientemente si están juntas o no.

Es más difícil de gestionar y se necesitan computadoras más potentes, pero se aprovecha muy bien la memoria. La fragmentación es casi cero.

Poco a poco, las páginas libres quedan muy desorganizadas. El sistema operativo puede perder tiempo en asignar muchas páginas no contiguas a los procesos, por lo que cada poco tiempo realiza una compactación. Esto consiste en organizar todas las páginas, de forma que tanto las páginas libres como las de los procesos estén juntas.

Por este motivo, la **paginación** es la técnica que se utiliza en la **actualidad**.

#### 5.2.- Memoria virtual (Windows) y memoria swap (Linux)

**Memoria virtual en Windows**

La memoria RAM es cara y limitada. Debido a esto nació este sistema, que consiste en sobrepasar el límite de memoria RAM, guardando la información en el disco duro como si fuera RAM.

La memoria virtual suele tener entre 1 y 2 veces el tamaño de la RAM.

Cada vez que se carga un proceso en la memoria RAM, también se escribe en la memoria virtual. Cuando la RAM se está llenando, se puede borrar las que sobran e introducir las nuevas. Si hacen falta las antiguas, se provocará un fallo de página, y el gestor de memoria traerá dicha parte del proceso de disco a memoria.

De esta forma, aunque la memoria virtual es más lenta que la RAM, si tenemos una RAM de 2 GB, podríamos simular una RAM de 6 GB con la ayuda de la memoria virtual en disco duro.

El archivo `pagefile.sys` oculto en la partición donde está instalado Windows es el archivo de la memoria virtual, también llamado archivo de paginación (pues también utiliza paginación dentro del archivo). Aun así, no hay que confundir la memoria virtual con la paginación a secas.

**Memoria swap o área de intercambio en GNU-Linux**

El concepto es el mismo que memoria virtual. La diferencia es que, en Linux, al instalar el sistema operativo, se crea una partición expresa para este fin. Lo habitual es utilizar entre 1 y 2 veces el tamaño de la RAM.

Ventajas de memoria swap sobre memoria virtual:

- No depende de que la partición de datos esté muy llena.
- Si se pone la swap en la primera partición del disco duro, gana en velocidad, pues esa zona del disco duro es más rápida.

En Linux se utiliza el comando `free` para ver cuanta memoria principal y cuánta swap tiene el equipo y su consumo.

Tendencia actual en la memoria swap o memoria virtual:

Actualmente, los ordenadores tienen memoria RAM muy grande, por lo que se discute si es necesario poner memoria virtual o swap o no configurarla.

En cualquier caso, en un ordenador con RAM muy grande se suele poner como tamaño de la virtual o swap la misma cantidad que tiene de RAM. Si la cantidad de RAM es justa, pondremos el doble. Una razón para seguirla poniendo en Linux, es que la partición swap se utiliza también cuando se hiberna el sistema.

### 6.- Gestión de entrada y salida

Una de las funciones del ordenador es procesar la información, que es obtenida y mostrada a través de los periféricos. La parte del sistema operativo que se encarga de este proceso es la **gestión de la E/S (entrada/salida)**.

#### 6.1.- Estructura y transferencia de datos

**Controladores de dispositivo**

Hay multitud de tipos y fabricantes de periféricos, esto conlleva que tanto el sistema operativo como los fabricantes de periféricos deben estandarizar el acceso a los dispositivos utilizando los controladores de dispositivos.

**Controlador o Driver**: software suministrado por el fabricante del dispositivo o el desarrollador del sistema operativo que actúa como interfaz entre los programas y el hardware.

**Estructura de datos de la E/S**

Se refiere a la estructura de datos que utilizan los dispositivos periféricos para manejar la información y comunicación entre dispositivos o entre estos y la CPU. Las más utilizadas son:

- **Spool**. Los datos de salida se almacenan de forma temporal en una cola situada en un dispositivo de almacenamiento masivo (*spool*), hasta que el periférico requerido se encuentre libre. De este modo se evita que un programa quede retenido porque el periférico no esté disponible. El sistema operativo dispone de llamadas para añadir y eliminar archivos del spool. Se utiliza en dispositivos que no admiten intercalación, como ocurre en la impresora, ya que no puede empezar una impresión hasta que no haya terminado la anterior.

- **Buffers**. Es para dispositivos que pueden atender peticiones de distintos orígenes. Los datos no tienen que enviarse completos, pueden enviarse porciones que el buffer retiene de forma temporal. También se utilizan para acoplar velocidades de distintos dispositivos. Así, si un dispositivo lento va a recibir información más rápido de lo que puede atenderla se emplea un buffer para retener temporalmente la información hasta que el dispositivo pueda asimilarla. Esto ocurre entre una grabadora de DVD y el disco duro, ya que la primera funciona a una menor velocidad que el segundo.

**Transferencia de los datos de la E/S**

Existen distintas formas de transferir los datos de E/S en los sistemas operativos según la intervención de la CPU. Son las siguientes, ordenadas de menos eficientes a más eficientes:

- **E/S programada**. La CPU tiene todo el protagonismo ya que inicia y lleva a cabo la transferencia. Esta técnica repercute en la velocidad de proceso del ordenador, porque la CPU debe dejar todo lo que está haciendo para ocuparse del proceso de entrada/salida.

- **E/S por interrupciones**. La CPU ejecuta la transferencia pero el inicio es pedido por el periférico que indica así su disponibilidad. La CPU no pregunta a los dispositivos sino que son estos los que la avisan cuando es necesario.

- **Acceso directo a memoria (DMA)**. La transferencia es realizada por un controlador especializado. Esta técnica acelera enormemente el proceso de la E/S y libera a la CPU de trabajo. Lo habitual es que los datos que se quieren escribir en el dispositivo o que son leídos del dispositivo provengan o vayan a la memoria del ordenador, pues bien en este caso. la CPU inicia el proceso, pero luego el dispositivo continúa sin necesitar a la CPU, con lo que se acelera mucho el proceso de entrada/salida y se libera a la CPU del proceso.

### 7.- Gestión de archivos
#### 7.1.- Organización lógica: directorios y ficheros

Cada sistema operativo utilizará su propio sistema de archivos, no obstante las operaciones que se pueden realizar sobre el sistema de archivos son bastante similares. Así, todos los sistemas de archivos actuales utilizan los directorios o carpetas para organizar a los archivos.

**Objetivos en la implementación de un sistema de archivos**

- Optimizar el rendimiento mediante un acceso rápido cuando se recupera información.
- Fácil actualización de los archivos.
- Intentar que los archivos desperdicien la menor cantidad de espacio en disco posible.
- Mantenimiento sencillo.
- Fiabilidad para asegurar que los datos sean correctos y fiables.
- Incorporar mecanismos de seguridad y permisos.
- Control de concurrencia.

**Organización lógica del sistema de archivos**

Los sistemas de archivos deben permitir utilizar el medio de almacenamiento (disco) de una forma intuitiva y cómoda, sin conocer los detalles de hardware.

A esto se le llama organización del sistema de archivos y suele coincidir en todos los sistemas de archivos actuales, utilizando el esquema de almacenamiento en archivos y la organización en carpetas o directorios.

Un directorio o carpeta solo es un contenedor, no contiene información, ésta se encuentra en los archivos.

Cada archivo de un sistema tendrá unos atributos que lo identifican:

1. Nombre
2. Extensión
3. Permisos
4. Propietario
5. Fecha de creación
6. Fecha del último acceso
7. Fecha de la última modificación
8. Tamaño actual

**Jerarquía de directorios. Árboles**

Todos los sistemas operativos tienen una estructura jerárquica de almacenamiento de la información en forma de árbol.

### 8.- Virtualización. Software y configuración de máquinas virtuales.

#### 8.1.- Motivación y ventajas de las máquinas virtuales.

Gracias a la virtualización o máquinas virtuales, en un ordenador puede haber varias máquinas distintas ejecutándose.

Las máquinas virtuales se pueden comunicar en una red, siendo vistas como computadores distintas.

Una máquina virtual, se instala y ejecuta bajo un software, de forma que es una carpeta con algunos archivos. El disco duro es un archivo, y el resto de archivos son la configuración de la máquina. De esta forma, resulta muy fácil el traslado de una máquina virtual de un ordenador a otro ordenador.

Términos:

- **Máquina anfitrión, host o servidor:** máquina real donde se instala la aplicación de virtualización.
- **Máquina invitada, huésped o guest**: máquina virtual que se ejecuta dentro de la aplicación.

**Software de virtualización**

Software de varias empresas: Vmware, Oracle, Microsoft, Parallels

- **Vmware**. Software propietario. Tiene muchas versiones, algunas de pago y otras gratuitas (Server, Workstation y Player).

- **VirtualBox**. Software original de Sun Microsystems, comprada posteriormente por Oracle. Tiene dos versiones principales (VirtualBox y VirtualBox OSE).

- **HiperV**. Software propietario de Microsoft para ordenadores con Windows. Tiene dos programas (Virtual PC e Hiper V).

- **Parallels**. Software propietario para ordenadores MAC. Se puede virtualizar tanto Windows como Linux.

#### 8.2.- Instalación y configuración de una máquina virtual nueva

Para crear una máquina, se indican los siguientes parámetros:

1. Nombre.
2. Sistema operativo que se va a instalar.
3. Memoria RAM.
4. Disco duro.

**Diferencia de tamaño fijo y tamaño dinámico al crear un disco duro**

Al crear un disco duro, se puede crear de tamaño dinámico (el archivo crece según metemos información en la máquina virtual) o tamaño fijo (el archivo ocupa siempre el tamaño total del disco duro). 

**Configuración de la máquina virtual**

Una vez creada una máquina virtual, se puede:

- Añadir o eliminar medios de almacenamiento.
- Habilitar los puertos USB de la máquina host.
- Configurar la red (NAT, puente, red interna).
- Compartir carpetas entre la máquina host y la invitada.

**Herramientas de optimización**

Para que las máquinas funcionen con mejores características, hay que instalar las herramientas que adaptan el hardware de la máquina real a la invitada (es decir, instalan u optimizan los drivers). Cada programa tiene su propia herramienta para este fin.

Ventajas de instalar estas herramientas:

- Mejor resolución gráfica.
- Integración del ratón.
- Acceso a carpetas compartidas.
- Compartir el portapapeles.

#### 8.3.- Configuración de VirtualBox

**Instantáneas o snapshots**

Si vamos a instalar algún programa, o queremos hacer pruebas al sistema, y pensamos que pueden fallar esas pruebas, podemos realizar instantáneas al sistema. De esa forma, una vez acabada las nuevas instalaciones o pruebas, podemos decidir, si nos quedamos con la versión más actualizada del Sistema Operativo (Eliminar instantánea) o la versión antigua (Restaurar instantánea). Cada instantánea va generando archivo .vdi nuevos con las diferencias.

**Extensiones de los discos duros, según programas**

- VirtualBox → vdi
- Vmware → vmdk
- Virtual PC → vhd

Aun así, no hay problema de compatibilidad entre VMware y VirtualBox, pues se pueden exportar e importar las máquinas.

**Trasladar una máquina a otro PC**

1. Disco duro. El disco duro de una máquina virtual, es un único archivo .vdi. Este archivo se puede copiar en cualquier otro ordenador y tener una máquina instalada en un momento. Hay que crear la máquina nueva y en el momento de poner disco duro elegir el disco existente con su ruta.

2. Máquina entera. Para ello se debe exportar el servicio virtualizado, obteniendo un archivo con extensión .ova.
Este archivo servirá para importar la máquina en ese PC o en otro. La diferencia, es que el archivo .ova es toda la máquina.

**Administrador de discos de VirtualBox**

Al igual que un disco duro físico no puede estar en 2 sitios a la vez, no podemos tener duplicado el disco duro en 2 máquinas virtuales, aunque se llamen de forma distinta y tengan cosas distintas.
Cada disco tiene un número de serie y no puede haber 2 archivos .vdi con el mismo número de serie.

**Soluciones**

Hay varias soluciones para copiar un disco sin provocar errores por UUID:

1. Copiar el disco (crea una copia con UUID distinto).
2. Clonar la máquina (no solo copia el disco, sino que crea otra máquina con sus archivos de configuración).
3. Exportar el servicio virtualizado (se genera el archivo .ova).

**Configuración de red en VirtualBox**

La máquina virtual tiene una tarjeta de red virtual (se pueden poner varias tarjetas de red virtuales).
Esta tarjeta de red virtual se conecta con la máquina anfitrión según la configuración que se seleccione. Las configuraciones posibles son:

- **No conectado** -> La máquina invitada no tiene red.
- **NAT: Network Address Translation** -> Modo más simple, pues sin ninguna configuración adicional la máquina virtual navega por Internet. La máquina virtual no se puede conectar ni con la anfitrión ni con otras máquinas virtuales y, por tanto, no puede compartir archivos. La dirección IP en la máquina invitada la asigna dinámicamente Virtualbox. Este modo es perfecto para realizar todo tipo de pruebas, ya que la red no puede infectar a la máquina y al contrario.
- **Bridged / Adaptador Puente** -> Se forma un puente entre la tarjeta virtual de la máquina invitada y la tarjeta real de la máquina anfitrión. Es como si fueran la misma tarjeta. A todos los efectos la máquina invitada es como si estuviera conectada a la red como una máquina real.
- **Red Interna** -> Crear una red interna visible entre las máquinas invitadas, pero no con la anfitrión ni con la red general. Se utiliza cuando queremos tener una red entre las máquinas virtuales.
- **Host-only networking / Adaptador sólo-anfitrión** -> En este modo cada máquina invitada solo puede comunicarse con la máquina anfitrión, sin que se puedan comunicar entre las invitadas. El direccionamiento de las mismas es dinámico y lo asigna VirtualBox.

## UD2.- Hardware de un sistema informático

![Esquema Unidad 2 Sistemas Informáticos](../../static/img/sistemas-informaticos-unidad-2.jpg)

### 1.- Computadores digitales. Evolución.

En la actualidad, todos los equipos que utilizamos son **computadores digitales**. Estos operan únicamente manejando dos estados, representados por **0** y **1** (sistema binario). 

- Esta base binaria proviene de los **transistores** dentro del microprocesador, que actúan como interruptores:
    - **Encendido** (paso de corriente) se asigna al valor **1**.
    - **Apagado** (sin paso de corriente) se asigna al valor **0**.
- Cada uno de estos estados se representa mediante un **bit**.
- Las operaciones lógicas y matemáticas que realiza el microprocesador se ejecutan mediante **circuitos electrónicos** que simulan las funciones booleanas.

El mundo digital es **discreto y finito** (solo representa algunos valores), mientras que el mundo analógico es **continuo e infinito** (puede representar todos los valores).

Aunque la conversión de datos analógicos a digitales produce errores porque solo se representan algunos valores, el mundo digital es preferido en la computación actual por sus ventajas prácticas y técnicas:
- **Exactitud (Inmunidad al ruido):** la comunicación digital es inherentemente más exacta y más inmune al ruido que la analógica.
- **Economía:** la comunicación digital es más barata de implementar.

**Conclusión:** los ordenadores actuales son digitales porque, a pesar de no poder representar todos los datos, los valores que sí representan son **más exactos**, **más inmunes al error** y se obtienen de forma **más económica**.

**Evolución de los computadores digitales**

| Generación | Periodo | Tecnología | Características |
| :--- | :--- | :--- | :--- |
| **Primera** | 1940-1960 | **Válvulas de vacío** | Eran muy pesados (ej., el **ENIAC** de 1946 pesaba 30 toneladas) y tenían poca potencia |
| **Segunda** | 1960-1965 | **Transistores** (sustituyen a las válvulas) | Desarrollados por los Laboratorios Bell. El peso disminuye, pero la potencia sigue siendo limitada |
| **Tercera** | 1965-1975 | **Circuitos Integrados** | Aumenta significativamente la **velocidad** de procesamiento |
| **Cuarta** | 1975-hoy | **Microprocesador** | Todos los circuitos integrados se condensan en una sola pastilla. Se consolida la **Arquitectura Von Neumann** que se utiliza hasta hoy |
| **Quinta** | 1985-hoy | **Inteligencia Artificial y Sistemas Expertos** | Los computadores tienen la capacidad de aprender de sus propios errores y cálculos anteriores | 

### 2.- Arquitectura Von Neumann

La **Arquitectura Von Neumann** es el modelo base de los computadores actuales, diseñado por John Von Neumann. Su gran novedad fue un concepto conocido como el **programa almacenado**: tanto los **datos** como las **instrucciones** de los programas se guardan en la **Memoria Principal (RAM)**, sin distinción. Es la **CPU** la encargada de diferenciar qué es dato y qué es instrucción en el momento de la ejecución. Este modelo se ha utilizado ininterrumpidamente desde el primer PC de IBM en 1981.

La arquitectura se compone de cuatro unidades interconectadas por buses:

1. **CPU (Unidad Central de Proceso):** el cerebro que ejecuta los programas.
2. **Memoria Principal (RAM):** almacena datos e instrucciones.
3. **Unidad de Entrada/Salida (E/S):** gestiona la comunicación con periféricos.
4. **Buses:** canales que transportan datos e instrucciones entre las unidades.

**1. Memoria Principal (RAM)**
    - Almacena los **datos y las instrucciones** de los programas activos y toda la información necesaria para el sistema.
    - Es **volátil**; su contenido se pierde cuando el ordenador se apaga.
    - Está formada por celdas de igual longitud, conocidas como **registros**.

**2. CPU: Unidad Central de Proceso**
    - Es el componente principal, y está compuesto por:
        - **Unidad de Control (UC):** se encarga de **gobernar** la ejecución de los programas, **controlando la secuencia** de las instrucciones e interpretando su significado. Controla también a los demás componentes del sistema (memoria, periféricos).
        - **Unidad Aritmético-Lógica (ALU):** realiza todos los **cálculos matemáticos** y **operaciones lógicas**.
        - **Registros y Caché:** son memorias muy rápidas ubicadas dentro de la CPU para almacenar datos o la dirección de la siguiente instrucción, con el fin de **reducir el acceso a la lenta memoria principal**.

    :::info Procesador de n bits
    Si un procesador es de **64 bits**, significa que la **longitud de palabra** (el tamaño de datos e instrucciones que maneja) es de 64 bits.

    La longitud de los registros, el ancho de la memoria caché, y el ancho de los **buses de datos y direcciones** suelen ser iguales a la longitud de palabra del procesador.
    :::

**3. Unidad de Entrada/Salida (E/S)**
    - Circuitos electrónicos que permiten el **intercambio de información** entre la CPU y los periféricos. Carga programas/datos a la RAM (Entrada) y saca resultados (Salida).
    - Los **discos duros** son considerados **dispositivos de E/S** bajo este modelo, ya que son externos a la memoria principal (RAM).

**4. Buses**
    - Conjunto de circuitos que permiten la **comunicación en paralelo** entre la CPU y el resto de unidades:
        - **Bus de Datos e Instrucciones:** traslada datos e instrucciones entre la memoria principal y las demás unidades.
        - **Bus de Control:** la CPU envía **órdenes** (microórdenes) y recibe **señales de estado** de las otras unidades.
        - **Bus de Direcciones:** transmite la **dirección de destino** o de origen de los datos que circulan por el bus de datos (ej., la posición de memoria a leer).

**Ejecución de las instrucciones**

Para que un programa se ejecute, debe estar alojado en la RAM. Las instrucciones se ejecutan secuencialmente, leyendo posiciones consecutivas de memoria La ejecución se divide en dos fases principales por cada instrucción:
    1.  **Fase de Búsqueda (Fetch):**
        * El **Contador de Programa (CP)** almacena la dirección de la siguiente instrucción a leer.
        * La instrucción se localiza en la memoria y se lleva a la CPU (UC).
        * La instrucción se almacena en el **Registro de Instrucción (RI)**.
    2.  **Fase de Ejecución:**
        * La **ALU** realiza el cálculo u operación lógica.
        * La ALU utiliza **registros operandos** para introducir datos y un **Registro Acumulador (AC)** para guardar el resultado.

:::info Jerarquía de Memoria
El computador utiliza múltiples tipos de memoria (Registros → Caché → RAM → Discos Duros) debido a un compromiso entre **coste y velocidad**. Cuanto más **rápida** es la memoria (más cerca de la CPU), **mayor es su precio** y **menor es su tamaño**.
:::

<iframe 
    width="560" 
    height="315" 
    src="https://www.youtube.com/embed/SxFG18C4gXQ?si=N1oqnWEI7tKqCaCm&amp;disablekb=1" 
    title="YouTube video player" 
    frameborder="0" 
    allowfullscreen>
</iframe>

### 3.- La CPU. El microprocesador.

El **microprocesador** es el elemento que representa la **CPU** (Unidad Central de Proceso) en la arquitectura Von Neumann. Es un microchip complejo, generalmente cerámico, que contiene millones de microcomponentes (transistores) y se acopla a la placa base mediante un zócalo. Los principales fabricantes de procesadores son **AMD** e **Intel**. Actualmente, todos los procesadores fabricados son de **64 bits**.

Debido al calor generado, la CPU requiere **refrigeración** (ventiladores o sistemas líquidos) para evitar daños.

**Características que definen un procesador**

| Característica | Descripción | Medida |
| :--- | :--- | :--- |
| Velocidad/Frecuencia | Ciclos por segundo u **operaciones elementales** que realiza el procesador | **GHz** (ej. 3 GHz = 3.000 millones de operaciones por segundo) |
| Litografía | Mide la tecnología de fabricación (el **tamaño de los transistores**). A menor tamaño, menor energía necesaria, y por tanto, **menor consumo y menor calor** generado | **Nanómetros** (nm). |
| Arquitectura | Define la **longitud de palabra** (ej. 64 bits), que es el tamaño de datos e instrucciones que el procesador y sus buses pueden manejar | Bits |

**Núcleos e hilos de ejecución**

La mejora de la CPU desde 2004 (cuando se alcanzó la velocidad máxima por calentamiento) se logró incorporando **múltiples núcleos**.

- **Núcleos (Cores):** cada núcleo es una unidad de procesamiento independiente que puede ejecutar un **proceso** por separado (los procesadores de alta gama tienen 6 a 8 núcleos para PC, y más para servidores).
- **Hilos (Threads):** en muchos procesadores, cada núcleo se divide en 2 hilos de ejecución. Un hilo permite que un proceso principal se subdivida en **subprocesos** que se ejecutan simultáneamente, mejorando la eficiencia.

**Memoria caché del procesador**

La **memoria caché** es una memoria muy rápida y cara ubicada dentro del procesador. Su objetivo es **reducir el número de accesos a la RAM** guardando los datos que se utilizan con mayor frecuencia, basándose en la regla 80/20 (el 20% de los datos se usan el 80% del tiempo). La caché se organiza en una jerarquía de hasta tres niveles:

| Nivel | Ubicación/Compartición | Velocidad/Precio | Tamaño |
| :--- | :--- | :--- | :--- |
| L1 | **Única para el procesador** (dividida en caché de datos y caché de instrucciones) | **Mayor** | **Menor** |
| L2 | Por núcleo o compartida entre algunos núcleos | Intermedia | Intermedio |
| L3 | **Única para todo el procesador** (compartida entre todos los núcleos) | **Menor** | **Mayor** |

Esta organización sigue la jerarquía de memoria: **a mayor velocidad, mayor precio y menor tamaño**. 

### 4.- Memoria RAM

La **Memoria RAM** (*Random Access Memory*, memoria de acceso aleatorio) es la **memoria principal** en la arquitectura Von Neumann. Su nombre indica que está optimizada para guardar y acceder a los datos de forma **no contigua**. Es **volátil**, lo que significa que su contenido se **borra al apagar** el ordenador, por lo que se usa para almacenar instrucciones y datos **en ejecución**.

Físicamente, los módulos de RAM son tarjetas con *chips* de memoria soldados y se insertan en los zócalos de la placa base mediante pines o contactos metálicos.

Todas las memorias RAM modernas son **SD-RAM** (*Syncronic Dynamic-Random Access Memory*). Se denominan:
    - **Dinámicas:** necesitan **refrescar la información constantemente**.
    - **Síncronas:** el refresco se realiza **a golpe de reloj**. 

**Características de la memoria**
    - **Frecuencia o velocidad**: indica la cantidad de **ciclos por segundo** u operaciones elementales que realiza la memoria. Se mide en **MHz** o **GHz**.
    - **Ancho de Banda**: cantidad de datos que se pueden transferir en 1 segundo. Su cálculo es: `velocidad (MHz) × ancho de datos (bytes)`.
    **CL o CAS - Latencia**: número de **ciclos de reloj** necesarios para acceder a la **primera celda** en una lectura o escritura. Una **menor latencia** indica una **mejor memoria**.

**Evolución (DIMM SD-RAM)**

Cada nueva generación de memoria (DDR, DDR2, DDR3, DDR4) mejora a la anterior, ofreciendo mayor frecuencia y menor consumo y calor.

| Tipo | Contactos (PC) | Muescas | Lecturas por ciclo | Voltaje |
| :--- | :--- | :--- | :--- | :--- |
| DIMM-SDRAM | 168 | 2 | 1 | N/A |
| DIMM-DDR | 184 | 1 | 2 | 2,5 V |
| DIMM-DDR2 | 240 | 1 | 4 | 1,8 V |
| DIMM-DDR3 | 240 | 1 | 8 | 1,5 V |
| DIMM-DDR4 | 284 | 1 | 16 | 1,2 V |

:::caution Advertencia 
Aunque todas las DDR tienen una única muesca, su posición es diferente en cada generación. Insertar un tipo de memoria incorrecto en un zócalo puede dañar tanto la memoria como la placa base.
:::

**Dual, Triple y Cuádruple Canal**

La tecnología **Dual Channel** habilita **dos canales paralelos** de transmisión de datos entre la RAM y el controlador de memoria, lo que **dobla el ancho de banda** (la transferencia de datos).
    - **Requisito:** los dos módulos de memoria deben ser **idénticos** (fabricante, capacidad, velocidad y latencias).
    - **Instalación:** en las placas base, los zócalos suelen estar codificados por colores, y los módulos idénticos deben instalarse en las ranuras de **igual color** (siempre verificar el manual de la placa).

Existen placas con soporte para **triple** y **cuádruple canal** para mayores tasas de transferencia.

### 5.- Componentes de un computador

#### 5.1- Cajas de ordenador

Las cajas de ordenador se definen por su tamaño y forma (factor de forma), lo que determina su capacidad interna (número de bahías).

- **Minitorre o semitorre:** la diferencia es la altura, determinada por el número de **bahías de 5.25 pulgadas** (2 en minitorre, 4 en semitorre).
- **Sobremesa:** similares a las minitorre, pero con orientación **horizontal**. Requieren rotar los dispositivos extraíbles en el frontal.
-  **Barebone y slim:** cajas de **pequeño tamaño** que admiten pocos o ningún dispositivo interno, compensando con más conectores externos.

El panel trasero muestra directamente los conectores de la placa base, las tarjetas de expansión, la toma de corriente y la ventilación de la fuente de alimentación.

#### 5.2- Fuentes de alimentación

La función principal de la fuente de alimentación es **transformar la corriente alterna (AC)** de la red eléctrica (ej. 230V en Europa) a **corriente continua (DC)** con voltajes inferiores que el *hardware* pueda usar.

| Voltaje de salida (DC) | Uso principal |
| :--- | :--- |
| +12V | Discos duros, ventiladores, disqueteras |
| +5V | Placa base y puertos USB |
| +3.3V | Algunas tarjetas de expansión y tipos de memoria |
| -12V / -5V | En desuso (antiguos puertos serie o tarjetas ISA) |

La característica más importante es la **potencia máxima** (medida en vatios, `W`), que debe ser suficiente para el *hardware* conectado (las fuentes estándar suelen ser de unos 500W. Una potencia insuficiente puede dañar el equipo.

**Conectores de la fuente de alimentación**

1.  **Alimentación a la placa base:**
    * **ATX v1.0 (20 pines):** conector principal.
    * **ATX v2.0 (24 pines / 20+4):** ampliación del conector principal, viene separado para compatibilidad con placas antiguas.
    * **Conector auxiliar 12V (P4):** proporciona energía adicional cerca del procesador. Evolucionó de 4 pines (P4) a 4+4 pines (8 en total) en la versión ATX v2.0.

2.  **Alimentación a dispositivos de almacenamiento:**
    * **Conector Molex:** para dispositivos IDE (discos duros, CD) y ventiladores adicionales.
    * **Conector Berg:** pequeño, para disqueteras (FDD) y primeros lectores de tarjeta (en desuso en fuentes modernas).
    * **Conector SATA:** conector moderno específico para discos duros y unidades ópticas SATA. (*Si una fuente antigua no tiene SATA, se pueden usar adaptadores Molex a SATA*).

3.  **Alimentación a tarjeta gráfica:**
    * **PCI-Express (6 u 8 pines):** conector para proporcionar **corriente adicional** a las tarjetas gráficas de alto rendimiento. No es obligatorio usarlo, pero es recomendable para que la tarjeta alcance su potencia máxima. 
 
#### 5.3.- Tarjetas gráficas
La **tarjeta gráfica** (o tarjeta de vídeo) es una tarjeta de expansión que tiene como función **adaptar los datos** enviados por el procesador para su **representación visual** en un monitor o proyector.

Actualmente, se conectan a la placa base a través del bus **PCI Express x16**. Muchas placas base incluyen una gráfica integrada, suficiente para el uso normal, pero no para un uso intensivo de gráficos.

**Componentes importantes**

| Componente | Siglas | Función |
| :--- | :--- | :--- |
| **GPU** | *Graphics Processing Unit* | Es el **procesador dedicado** de la tarjeta gráfica; realiza los cálculos necesarios para determinar los colores de cada píxel en la pantalla. |
| **Memoria de Vídeo** | GDDR (ej., GDDR5) | Almacena los datos de las imágenes a representar. **A mayor memoria, mejor será la resolución gráfica posible**. |
| **RAMDAC** | *Random Access Memory Digital-to-Analog Converter* | Convierte las señales digitales internas del ordenador a **señales analógicas** requeridas por algunos monitores. Está perdiendo importancia debido al auge de los monitores digitales. |

**Conectores al monitor**

Las tarjetas pueden tener salidas analógicas y/o digitales:
    - **VGA:** conexión **analógica**.
    - **DVI:** puede ser analógica (`DVI-A`), digital (`DVI-D`), o ambas (`DVI-I`).
    - **HDMI:** conexión **digital** más extendida. 

### 6.- Placa base

La **placa base** (*motherboard*) es el gran circuito impreso central del ordenador. En el contexto del modelo Von Neumann, equivale al conjunto de **buses de comunicación** que interconectan todos los demás componentes.

#### 6.1- Componentes de la placa base

![Imagen de una placa base](../../static/img/placa-base.jpg)

A continuación se detallan los principales componentes y conectores de la placa base, utilizando la imagen adjunta como referencia visual para facilitar el montaje y el mantenimiento: 

| ID | Componente | Uso |
| :---: | :--- | :--- |
| **1** | **Zócalo** | Se inserta el **microprocesador**. |
| **2** | **Chipset (Puente Norte)** | Gestiona la comunicación rápida. **Desaparece en placas actuales**. |
| **3** | **Chipset (Puente Sur)** | Gestiona la comunicación lenta. **Se mantiene en placas actuales**. |
| **4** | **Zócalos DIMM DDR2** | Ranuras para insertar los módulos de **Memoria RAM** (en este caso, tipo DDR2). |
| **5** | **Conector ATX (24 pines)** | Conector principal de la **fuente de alimentación** a la placa base. |
| **6** | **Conector 12V** | Conector adicional de alimentación para el **procesador** (antiguo conector de 4 pines, hoy 8 pines). |
| **7 y 8** | **Ranuras PCI Express 1x** | Ranuras pequeñas para tarjetas de expansión. |
| **9** | **Ranura PCI Express 16x** | Ranura larga y principal para la **tarjeta gráfica**. |
| **10** | **Ranuras PCI** | Ranuras para tarjetas de expansión antiguas. |
| **11** | **Conectores SATA** | Puertos de conexión de datos para **discos duros** y **unidades DVD SATA**. |
| **12** | **Conector IDE (40 pines)** | Conexión de datos para discos duros y DVD IDE (obsoleto en placas actuales). |
| **13** | **Conector FDD (34 pines)** | Conexión de datos para disqueteras antiguas (obsoleto en placas actuales). |
| **14** | **Panel frontal** | Conectores para los botones (*power*, *reset*) y LEDs de la caja del PC. |
| **15** | **Conector USB** | Puertos para conectar los **USB frontales** de la caja. |
| **16** | **Conector AAFP (Audio)** | Conector para el **Audio frontal** de la caja (auriculares y micrófono). |
| **17** | **CPU_FAN y PWR_FAN** | Conectores para el **ventilador del procesador** (CPU_FAN) y ventiladores adicionales de la caja (PWR_FAN). |
| **18** | **BIOS** | Chip que almacena el *software* de **inicio** que se ejecuta al encender el ordenador. |
| **19** | **Panel trasero ATX** | Conjunto de puertos que asoman por la parte trasera de la caja. |
| **20** | **Agujeros tornillos** | Puntos de sujeción para acoplar la placa base al chasis de la caja (mínimo de 6 tornillos). |

#### 6.2.- Panel trasero ATX

El **panel trasero ATX** es el conjunto de conectores integrados en la propia placa base que asoman por la parte trasera de la caja (introducido alrededor de 1995).

- **USB:** los puertos **USB 2.0** suelen ser **negros**, mientras que los **USB 3.0** son **azules**. Los USB amarillos permiten cargar dispositivos incluso con el PC apagado.
- **Monitores:** incluye conectores analógicos (**VGA**) y digitales (**DVI, HDMI, DisplayPort**).
    * **HDMI** se diseñó pensando en televisores.
    * **DisplayPort** (creado por AMD) se diseñó para ordenadores.
- **Conectores especiales:**
    * **Firewire (IEEE 1394):** utilizado históricamente para cámaras de vídeo de consumo.
    * **eSATA:** permite conectar discos duros SATA externos sin abrir la caja.
    * **SPIDF Out:** conexión de salida **óptica digital** para altavoces.

Se recomienda usar los puertos USB integrados del panel trasero para dispositivos externos (como *pendrives* o discos duros) en lugar de los frontales de la caja, ya que no hay *hardware* intermedio.

#### 6.3.- Zócalo de la placa base

El **zócalo** es el lugar en la placa base donde se inserta y fija el microprocesador, sobre el cual se monta el ventilador. Es crucial colocar el procesador correctamente, fijándose en las muescas, ya que es una de las partes más delicadas del montaje.

Existen varios tipos de zócalos, siendo los más comunes actualmente:
    - **ZIF** (*Zero Insertion Force*): utilizado principalmente por procesadores **AMD**. Los **pines** están en el **procesador**. El procesador se fija bajando una palanca.
    - **LGA** (*Land Grid Array*): utilizado por procesadores **Intel**. Los **pines** están en el **zócalo** (placa base) y el procesador tiene contactos planos. Permite mayor velocidad de buses.

#### 6.4.- Ranuras de expansión.

Las **ranuras de expansión** se utilizan para insertar tarjetas que **amplían** la funcionalidad del ordenador (gráficas, sonido, USB 3.0, etc.).

- **En desuso:** **AGP** (solo para tarjetas gráficas) y **PCI de 32 bits** (transferencia en paralelo).
- **Actuales (PCI Express):**
    * Utilizan **transferencia serie** (los datos se envían uno detrás de otro).
    * Existen con diferentes velocidades/longitudes (`1x`, `4x`, `8x`, `16x`). Una ranura **16x** es físicamente más larga y 16 veces más rápida que una 1x.
    * Se puede instalar una tarjeta de menor velocidad (ej. 4x) en una ranura más larga (ej. 16x), pero no al contrario.
    * Existen varias versiones (**PCI-Express 1, 2 y 3**) que se diferencian por las velocidades admitidas.

#### 6.5.- Chipset

El **chipset** es el componente más importante de la placa base, responsable de decidir las **capacidades** de la placa (tipo de procesadores, tipo y máximo de memoria RAM, ranuras y puertos admitidos).

Originalmente consistía en dos *chips* principales:
    1. **Northbridge (Puente Norte):** era responsable de conectar la **CPU** con los componentes de **alta velocidad** (Memoria RAM y Tarjeta Gráfica). **En las placas base actuales, ha desaparecido**, siendo sus funciones asumidas directamente por el microprocesador.
    2. **Southbridge (Puente Sur):** se encarga de la conexión de todos los **periféricos** y dispositivos de **almacenamiento** (SATA, IDE, USB, ranuras de expansión). Este componente **se mantiene** en las placas actuales. 

#### 6.6.- Conectores de almacenamiento

Los conectores de almacenamiento en la placa base permiten la conexión de discos duros, unidades de DVD y disqueteras mediante cables:
- **IDE** (40 pines): **en desuso**. Utilizado para antiguos discos duros y unidades ópticas. Se usa principalmente en tareas de mantenimiento.
- **FDD - Disquetera** (34 pines): **en desuso**. Para *floppy disks* (disqueteras antiguas).
- **SATA** (7 pines): el **estándar actual** para discos duros, SSD y unidades ópticas.

#### 6.7.- Conectores USB y Audio

La placa base incluye conectores internos de ampliación que permiten habilitar los puertos frontales y de audio de la caja:
- **Conectores USB:** cada conector interno de la placa base generalmente soporta **dos dispositivos USB**. Estos conectores se utilizan para conectar los puertos USB frontales de la caja. 
- **Conectores Audio:** el cable del audio frontal de la caja (auriculares y micrófono) se conecta al conector interno de la placa base (a menudo etiquetado como **AAFP**).

#### 6.8.- Panel frontal

El **Panel Frontal** es el conjunto de conexiones necesarias para que los botones (*power*, *reset*) y los indicadores LED de la caja funcionen. Estos cables soldados a los botones/LED de la caja deben conectarse a los pines correctos en la placa base.
- **Power SW:** botón de **encendido**.
- **Power Led (P-Led):** LED indicador de que el equipo está encendido.
- **Reset:** botón de **Reinicio**.
- **HDD-Led (IDE-Led):** LED que se enciende durante la actividad de lectura/escritura del disco duro.
- **Speaker:** conexión para el altavoz interno (bocina de la placa base).

Algunos fabricantes facilitan esta tarea mediante **conectores puente** que agrupan varios pines en un solo bloque.

#### 6.9.- La BIOS

La **BIOS** (*Basic Input/Output System*) es el **primer programa básico** que se ejecuta al encender el ordenador. Su objetivo inicial es ejecutar el **POST** (*Power-On Self-Test*), un proceso que **comprueba el *hardware*** esencial (procesador, memoria, etc.) antes de dar paso al arranque del sistema operativo desde el disco duro.

* **Programa Setup:** la BIOS incorpora un programa llamado **Setup** que permite al usuario modificar la configuración:
    * **Secuencia de arranque** (ej., CD antes que disco duro).
    * Fecha, hora y contraseñas de inicio.
    * Opciones avanzadas como **overclocking** (aumentar la velocidad del procesador, bajo riesgo).
* **Acceso:** para acceder al Setup, se debe pulsar una tecla específica (ej. **Esc, F2, Supr** o **DEL**) al iniciar el equipo.
* **Mantenimiento de datos:** los datos de configuración del usuario se mantienen mediante electricidad. Si el PC está desconectado, se utiliza la **pila CR2032**; si está gastada, aparecerá el mensaje "CMOS fail" y los datos de usuario se habrán borrado.
* **Actualización:** Hoy en día, la mayoría de las BIOS son **actualizables** (programables) desde la web del fabricante (a menudo usando un *pendrive*). Esta operación es delicada; un fallo o corte de luz puede dañar permanentemente la placa base.

#### 6.10.- Jumpers

Los **jumpers** son pequeños **pines** que sobresalen de la placa base y se unen mediante una pequeña **caperuza metálica** recubierta de plástico. Se utilizan para **fijar un parámetro variable** de funcionamiento de la placa.

Aunque las placas modernas traen pocos *jumpers* (1 o 2), se usan para tareas críticas como **borrar los parámetros de la BIOS** almacenados (restablecer a valores de fábrica).
    - *Ejemplo de borrado:* cambiar el *jumper* de la posición 'Normal' a 'Clear' (limpiar) y reiniciar, lo cual borra las contraseñas o configuraciones inaccesibles.

Algunos *jumpers* (como KBPWR o USBPW) pueden habilitar la función de **encender el ordenador** mediante el teclado o una señal a través del puerto USB, respectivamente. 

### 7.- Dispositivos de entrada y salida: memoria secundaria

La memoria secundaria (o auxiliar) es donde se leen y guardan los datos de forma permanente (discos duros, SSD, pendrives, etc.), ya que la CPU y la RAM solo manejan datos en tiempo de ejecución.

#### 7.1.- Características generales de los discos duros

| Característica | Descripción | Medida estándar |
| :--- | :--- | :--- |
| Capacidad | Espacio total para guardar datos | Terabytes |
| Velocidad de transferencia | Cantidad de datos transferidos por segundo | Megabytes por segundo |
| Tamaño físico | Dimensiones del disco | 3.5 pulgadas (PC de escritorio) o 2.5 pulgadas (portátiles) |
| Velocidad de rotación (*rpm*) | Vueltas que da el disco en un minuto | 7200 rpm (3.5 pulgadas) o 5400 rpm (2.5 pulgadas) |
| Tiempo de búsqueda | Tiempo para desplazar las cabezas de una pista a otra | Milisegundos |
| Latencia | Tiempo para que pase el sector requerido bajo la cabeza, una vez en la pista adecuada | Milisegundos |
| Tiempo de acceso | Tiempo total para colocarse sobre el sector a leer/escribir | Tiempo de búsqueda + Latencia |

#### 7.2.- Interfaces de conexión de discos duros   

| Interfaz | Tipo de transferencia | Velocidad y uso | Alimentación |
| :--- | :--- | :--- | :--- |
| IDE o PATA (*Parallel-ATA*) | Paralela |*Obsoleto. Conector de datos de 40 pines. | Conector Molex |
| SATA (*Serial-ATA*) | Serie | **Estándar actual**. Permite desconexión en caliente. | Conector de 15 pines |
| SCSI (*Small Computers System Interface*) | Paralela | Utilizado históricamente en **servidores**. Más rápido que PATA. | Conector Molex |
| SAS (*Serial Attached SCSI*) | Serie | **Opción actual para servidores**. Combina tecnología **SCSI** con interfaz **Serial** | Controladoras SCSI y discos SATA/SAS |

#### 7.3.- Comparativa HD y SSD

| Característica | HD | SSD |
| :--- | :--- | :--- |
| Estructura | Partes móviles (cabezas, pistas, sectores) | No mecánicos (tecnología *flash*) |
| Velocidad | Lento por retrasos mecánicos | Muy rápido (sin retrasos mecánicos) |
| Resistencia | Sensible a golpes y vibraciones | Muy resistente a golpes |
| Vida útil | Basada en fallos mecánicos | **Limitada** por un número máximo de ciclos de lectura/escritura (problema para servidores, no para PC) |
| Precio/Recuperación | Barato. Datos recuperables en caso de avería física. | Caro. Datos casi imposibles de recuperar en caso de avería. |
| Conexión | PATA/SATA | SATA, USB y PCI-Express |

:::info Estructura física del HD
La información se organiza en **pistas** y **sectores**. La velocidad es mayor en las pistas exteriores que en las interiores. 
:::

#### 7.4.- Conexiones USB. Pendrives.

La evolución de la interfaz USB ha supuesto un incremento drástico en la velocidad de transferencia, con el **USB 3.0** siendo 10 veces más rápido que el **USB 2.0**.

| Denominación | Velocidad |
| :--- | :--- |
| USB 1 | 1.5 MB/seg |
| USB 2.0 | 60 MB/seg |
| USB 3.0 (Gen 1) | 600 MB/seg |
| USB 3.1 (Gen 2) | 1200 MB/seg |

La especificación USB 3.0 ahora se denomina **USB 3.1 Generación 1**.

**Pendrives y Memoria Flash**

Los *pendrives* son unidades de **memoria no volátil** (tecnología *flash*), siendo tecnológicamente similares a las unidades SSD.
    - **Velocidad:** existen grandes diferencias de velocidad y calidad entre modelos. Es común que los *pendrives* no alcancen la velocidad máxima teórica de la interfaz del puerto.
    - **Recomendación de compra:** es aconsejable comprar memorias **USB 3.0** ya que, incluso si se conectan a un puerto USB 2.0 antiguo, su mejor calidad interna garantiza una velocidad de transferencia más rápida que un *pendrive* 2.0 de gama baja.
    - **Recuperación de datos:** en caso de avería, la **recuperación de datos es difícil**.

:::tip
Al comprar cualquier dispositivo de almacenamiento (incluidas las tarjetas de memoria), no hay que fijarse solo en el precio, sino **comparar las velocidades reales** de transferencia, ya que varían mucho entre dispositivos de la misma especificación.
::: 

### 8.- Dispositivos de entrada y salida: periféricos

Los **periféricos** son unidades externas que se conectan al ordenador a través de los buses de entrada/salida para integrarse en el sistema. Ejemplos habituales incluyen el teclado, ratón, monitor, impresora y conexión de red.

Según su función, se clasifican en:
    - **Unidades de entrada:** introducen información o datos desde el exterior a la memoria central (ej., teclado, escáner).
    - **Unidades de salida:** sacan los datos o resultados de los procesos al exterior de forma comprensible para el usuario (ej., monitor, impresora).
    - **Unidades de entrada/salida:** se utilizan para ambos flujos (ej., tarjetas de red, que envían y reciben tráfico).

**Impresora**

Dispositivo de salida que transfiere información del ordenador al papel. Puede conectarse por USB o red.

| Tipo de impresora | Tecnología | Uso |
| :--- | :--- | :--- |
| Matricial | Impacto sobre una cinta | La más económica. Solo se utiliza con papel continuo. |
| Inyección de tinta | Tinta líquida | Ofrece los mejores resultados en color, pero es la más cara por consumibles |
| Láser | Tóner | Más barata para la impresión de **grandes cantidades** de papel con resultados muy aceptables |

**Monitor**

Dispositivo de salida que muestra la imagen proporcionada por la tarjeta gráfica.
    - **Tamaño:** se mide por la longitud de su **diagonal** en **pulgadas**.
    - **Tamaño del punto (*Dot Pitch*):** distancia entre dos puntos del mismo color. A **menor** tamaño del punto, **mejor definición** y mayor nitidez de la imagen (el estándar es 0.24 mm).
    - **Resolución máxima:** número total de píxeles (puntos) que la pantalla puede representar (píxeles horizontales x verticales). A mayor resolución, mejor calidad de imagen.
    - **Conexión:** puede ser **analógica** (VGA) o **digital** (HDMI, DVI).
    - **Clasificación:** la tecnología ha evolucionado de **CRT** (Tubo de Rayos Catódicos, en desuso) a **LCD** (Pantalla de Cristal Líquido) y, actualmente, a **LED** (más usados por su bajo consumo).

**Escáner**

Dispositivo de entrada que convierte un documento de papel (señal analógica) a un lienzo digital (datos binarios).
    - **Proceso:** el documento de papel (medidas en cm) se convierte en un documento digital (medidas en píxeles).
    - **Factor de conversión:** se utiliza el parámetro **ppp** (píxel por pulgada), donde 1 pulgada equivale a 2.54 cm.
    - **Cálculo de píxeles:** dimensiones en pulgadas x ppp.
    - **Ejemplo:** escanear una foto de 6 x 4 pulgadas a 300 ppp resulta en una imagen de 1800 x 1200 píxeles (aprox. 2 megapíxeles).

:::note Observación
Las cámaras fotográficas tienen muchos megapíxeles no porque se necesite para ver en pantalla, sino para asegurar una **buena resolución para imprimir o retocar** la foto. 
:::

### 9.- Montaje del ordenador

Antes de manipular los componentes de un computador, es crucial aplicar medidas de seguridad para proteger tanto al técnico como al *hardware* electrónico.

**Prevención de riesgos laborales. Medidas de seguridad.**

1.  **Seguridad física:** siempre **desconecta la alimentación** eléctrica antes de instalar o desinstalar cualquier componente del equipo.
2.  **Electricidad Estática:** la electricidad estática puede dañar gravemente los componentes electrónicos, aunque no es peligrosa para las personas. Para prevenirla:
    - Utiliza una **pulsera antiestática** conectada a una toma de tierra (o a una chapa metálica de la caja).
    - En su defecto, **toca la caja metálica** constantemente para descargarte.
3.  **Herramientas:** mantén las herramientas necesarias a mano y bien ordenadas.

**Montaje de un PC**

1.  **Montar placa base**
        - Colocar los separadores necesarios en la caja.
        - Atornillar la placa base a la caja.
2.  **Montar procesador y ventilador en la placa base**
        - Insertar el microprocesador en su zócalo.
        - Aplicar pasta térmica sobre el microprocesador.
        - Colocar el ventilador encima del procesador y conectar su cable al conector *CPU_Fan*.
3.  **Instalar RAM**
        - Insertar los módulos de RAM, asegurándose de que son la **versión DDR correcta** y que quedan bien encajados.
4.  **Conectar conectores de alimentación de la fuente de alimentación a la placa base**
5.  **Conectar panel frontal, USB y audio delanteros en la placa base.**
6.  **Instalar dispositivos de almacenamiento con sus 2 conexiones: datos y alimentación**
7.  **Instalar posibles tarjetas de expansión**

:::tip Recomendación
Se aconseja leer completamente el **manual de la placa base** para entender la ubicación precisa y las especificaciones de todos los conectores y *hardware* a conectar.
:::

## UD3.- Explotación de Windows. Particiones de discos.

![Esquema Unidad 3 Sistemas Informáticos](../../static/img/sistemas-informaticos-unidad-3.jpg)

### 1.- Versiones de Windows. Ventanas *Propiedades equipo* y *Administrar*.

Esta sección introduce las características de **Windows 10** y las distintas versiones disponibles, destacando la importancia de elegir la versión adecuada para las necesidades del usuario.

#### 1.1.- Versiones de Windows. Ciclo de vida.

**Versiones principales de Windows 10**

| Versión | Uso | Funciones |
| :--- | :--- | :--- |
| Windows 10 N | Tablets y móviles con procesador *ARM* | No compatible con procesadores Intel/AMD |
| Windows 10 Home | Mercado doméstico | Es la versión más común que se vende preinstalada |
| Windows 10 Pro | Empresas y profesionales | Conexión a dominio (para trabajar con Windows Server), Cifrado con Bitlocker y EFS, establecimiento de políticas de grupo, escritorio de acceso remoto y soporte para hasta 256 procesadores |
| Windows 10 Enterprise | Grandes empresas | Versión con ligeras mejoras sobre Pro, adquirida mediante licencias corporativas o por volumen |

>*ARM es una arquitectura de 32 bits de baja potencia y bajo consumo.*

**Requisitos mínimos de hardware**

Para una experiencia de usuario fluida, se recomienda un *hardware* superior a estos mínimos:
    - **Procesador:** 1 GHz o superior (x86 o x6).
    - **Memoria RAM:** 1 GB (32 bits) o 2 GB (64 bits).
    - **Espacio en disco:** 16 GB (32 bits) o 20 GB (64 bits).
    - **Gráficos:** DirectX 9 con controlador WDDM 1.0.

**Ciclo de vida de Windows**

El **ciclo de vida** define el tiempo durante el cual un sistema operativo recibirá **soporte técnico** de Microsoft. Una vez que finaliza, se requiere una migración a un sistema más moderno.

#### 1.2.- *Propiedades del equipo* y *Administrar*

Para obtener detalles de la versión de Windows 10 instalada y las especificaciones básicas del *hardware*, se accede a la ventana **Propiedades del equipo**. Una vez dentro, se puede ver información como: 
    1.  **Versión de Windows 10** instalada (ej., Home, Pro, Enterprise).
    2.  Información esencial del *hardware*: **tipo de procesador** y cantidad de **RAM** instalada.
    3.  **Nombre de la máquina** (el identificador de red del equipo).
    4.  Estado de la **activación de Windows**.
    5.  Acceso directo al **Administrador de dispositivos** (para ver y gestionar el *hardware*).
    6.  Acceso a la **Configuración avanzada del sistema**.

### 2.- Estructura lógica de un disco duro: particiones y sistemas de archivos

Para tener un control total de la instalación de Windows, es necesario conocer cómo se guarda la información en los discos duros.

#### 2.1.- Herramientas para crear particiones

Existen herramientas internas del sistema operativo y herramientas externas para gestionar particiones:

**Herramientas internas:**
    - **Microsoft:** se utiliza `diskpart` (en modo comando) junto con la herramienta gráfica **Administrador de discos**.
    - **Unix/Linux:** se utiliza **`fdisk`**.

**Herramientas externas:**
    - No pertenecen al núcleo del sistema operativo. Las más conocidas son **GParted** (*software libre*) y **Easeus Partition Master** (*software propietario*). Sus ventajas son que permiten crear particiones tanto de Windows como de Linux y además ofrecen funcionalidades avanzadas como **redimensionar** (cambiar el tamaño) y **mover** particiones.

**Administrador de discos de Windows**

El Administrador de discos muestra la estructura completa del disco, incluyendo particiones visibles y ocultas (como la partición de sistema de 500MB) y el **espacio no asignado**.

* **Creación de particiones:** Para crear una partición (ej. de 20 GB), se selecciona el **espacio no asignado**, se usa el menú contextual y se elige **"Nuevo volumen simple"**, especificando el tamaño (ej. 20000 MB), una letra de unidad y un sistema de archivos (ej., **NTFS**).
* **Montaje de particiones:** Cuando se crea una partición y se le asigna una letra (ej., F:), se dice que "se ha **montado** la partición".
* **Resolución de conflictos de letras:** Si la letra de unidad asignada a la nueva partición entra en conflicto con un recurso de red ya existente (como una carpeta compartida), se debe usar el Administrador de discos para **"Cambiar letra de unidad"** y seleccionar una letra libre.

**GParted**

GParted es una popular herramienta externa (comúnmente incluida en distribuciones Linux como Ubuntu) que se puede utilizar para gestionar particiones de cualquier sistema operativo arrancando desde un CD o *pendrive*.